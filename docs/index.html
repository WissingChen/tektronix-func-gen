<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>tektronix_func_gen API documentation</title>
<meta name="description" content="Tektronix arbitrary function generator control through PyVISA â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tektronix_func_gen</code></h1>
</header>
<section id="section-intro">
<h2 id="tektronix-arbitrary-function-generator-control-through-pyvisa">Tektronix arbitrary function generator control through PyVISA</h2>
<p>Andreas Svela 2020</p>
<p>To build the documentation use <a href="https://pdoc3.github.io/pdoc/">pdoc3</a> and
run <code>$ pdoc --html tektronix_func_gen</code></p>
<p>Tested on Win10 with NI-VISA.</p>
<h2 id="todo">Todo</h2>
<ul>
<li>add AM/FM capabilites</li>
</ul>
<h2 id="notes">Notes</h2>
<ul>
<li><strong>For TekVISA users:</strong> a <code>pyvisa.errors.VI_ERROR_IO</code> is raised unless
the Call Monitor application that comes with TekVISA is open and capturing
(see issue <a href="https://github.com/asvela/tektronix-func-gen/issues/1">#1</a>)</li>
<li>The offset of the built-in DC function cannot be controlled. A workaround
is to transfer a flat custom waveform to a memory location, see README.md
-&gt; Arbitrary waveforms -&gt; Flat function offset control</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
## Tektronix arbitrary function generator control through PyVISA

Andreas Svela 2020

To build the documentation use [pdoc3](https://pdoc3.github.io/pdoc/) and
run `$ pdoc --html tektronix_func_gen`

Tested on Win10 with NI-VISA.

Todo:
  * add AM/FM capabilites

Notes:
  * **For TekVISA users:** a `pyvisa.errors.VI_ERROR_IO` is raised unless
    the Call Monitor application that comes with TekVISA is open and capturing
    (see issue [#1](https://github.com/asvela/tektronix-func-gen/issues/1))
  * The offset of the built-in DC function cannot be controlled. A workaround
    is to transfer a flat custom waveform to a memory location, see README.md
    -&gt; Arbitrary waveforms -&gt; Flat function offset control
&#34;&#34;&#34;

import copy
import pyvisa
import numpy as np


## ~~~~~~~~~~~~~~~~~~~~~ FUNCTION GENERATOR CLASS ~~~~~~~~~~~~~~~~~~~~~~~~~~ ##

class FuncGen():
    &#34;&#34;&#34;Class for interacting with Tektronix function generator

    Parameters
    ----------
    address : str
        VISA address of insrument
    impedance : tuple of {&#34;highZ&#34;, &#34;50ohm&#34;}, default (&#34;highZ&#34;,)*2
        Determines voltage limits associated with high impedance (whether the
        instrument is using 50ohm or high Z cannot be controlled through VISA).
        For example `(&#34;highZ&#34;, &#34;50ohm&#34;)` for to use high Z for ch1 and
        50 ohm for ch2
    timeout : int, default 5000
        Timeout in milliseconds of instrument connection
    verify_param_set : bool, default False
        Verify that a value is successfully set after executing a set function
    verbose : bool, default `True`
        Choose whether to print information such as model upon connecting etc
    override_compatibility : bool, default `False`
        If the instrument limits for the model connected to are not known
        `NotCompatibleError` will be raised. To override and use AFG1022 limits,
        set to `True`. Note that this might lead to unexpected behaviour for
        custom waveforms and &#39;MIN&#39;/&#39;MAX&#39; keywords.

    Attributes
    ----------
    address : str
        The VISA address of the instrument
    id : str
        Comma separated string with maker, model, serial and firmware of
        the instrument
    inst : `pyvisa.resources.Resource`
        The PyVISA resource
    channels : tuple of FuncGenChannel
        Objects to control the channels
    ch1 : FuncGenChannel
        Short hand for `channels[0]` Object to control channel 1
    ch2 : FuncGenChannel
        Short hand for `channels[1]` Object to control channel 2
    instrument_limits : dict
        Contains the following keys with subdictionaries
        `frequency lims`
            Containing the frequency limits for the instrument where the keys
            &#34;min&#34; and &#34;max&#34; have values corresponding to minimum and maximum
            frequencies in Hz
        `voltage lims`
            Contains the maximum absolute voltage the instrument can output
            for the keys &#34;50ohm&#34; and &#34;highZ&#34; according to the impedance setting
        `amplitude lims`
            Contains the smallest and largest possible amplitudes where the
            keys &#34;50ohm&#34; and &#34;highZ&#34; will have subdictionaries with keys
            &#34;min&#34; and &#34;max&#34;
    arbitrary_waveform_length : list
        The permitted minimum and maximum length of an arbitrary waveform,
        e.g. [2, 8192]
    arbitrary_waveform_resolution : int
        The vertical resolution of the arbitrary waveform, for instance 14 bit
        =&gt; 2**14-1 = 16383

    Raises
    ------
    pyvisa.Error
        If the supplied VISA address cannot be connected to
    NotCompatibleError
        If the instrument limits for the model connected to are not known
        (Call the class with `override_compatibility=True` to override and
        use AFG1022 limits)
    &#34;&#34;&#34;

    def __init__(self, address, impedance=(&#34;highZ&#34;,)*2, timeout=5000,
                 verify_param_set=False, override_compatibility=False,
                 verbose=True):
        self.override_compatibility = override_compatibility
        self.address = address
        self.timeout = timeout
        self.verify_param_set = verify_param_set
        self.verbose = verbose
        try:
            rm = pyvisa.ResourceManager()
            self.inst = rm.open_resource(address)
        except pyvisa.Error:
            print(&#34;\nVisaError: Could not connect to \&#39;{}\&#39;&#34;.format(address))
            raise
        self.inst.timeout = self.timeout
        # Clear all the event registers and queues used in the instrument
        # status and event reporting system
        self.write(&#34;*CLS&#34;)
        # Get information about the connected device
        self.id = self.query(&#34;*IDN?&#34;)
        # Second query might be needed due to unknown reason
        # (suspecting *CLS does something weird)
        if self.id == &#39;&#39;:
            self.id = self.query(&#34;*IDN?&#34;)
        self.maker, self.model, self.serial = self.id.split(&#34;,&#34;)[:3]
        if self.verbose:
            print(&#34;Connected to {} model {}, serial&#34;
                  &#34; {}&#34;.format(self.maker, self.model, self.serial))
        self.initialise_model_properties()
        self.channels = (self.spawn_channel(1, impedance[0]),
                         self.spawn_channel(2, impedance[1]))
        self.ch1, self.ch2 = self.channels

    def __enter__(self, **kwargs):
        # The kwargs will be passed on to __init__
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def __del__(self):
        self.close()

    def close(self):
        &#34;&#34;&#34;Close the connection to the instrument&#34;&#34;&#34;
        self.inst.close()

    def initialise_model_properties(self):
        &#34;&#34;&#34;Initialises the limits of what the instrument can handle according
        to the instrument model

        Raises
        ------
        NotCompatibleError
            If the connected model is not necessarily compatible with this
            package, slimits are not known.
        &#34;&#34;&#34;
        if self.model == &#39;AFG1022&#39; or self.override_compatibility:
            self.instrument_limits = {
                &#34;frequency lims&#34;: ({&#34;min&#34;: 1e-6, &#34;max&#34;: 25e6}, &#34;Hz&#34;),
                &#34;voltage lims&#34;:   ({&#34;50ohm&#34;: {&#34;min&#34;: -5, &#34;max&#34;: 5},
                                    &#34;highZ&#34;: {&#34;min&#34;: -10, &#34;max&#34;: 10}}, &#34;V&#34;),
                &#34;amplitude lims&#34;: ({&#34;50ohm&#34;: {&#34;min&#34;: 0.001, &#34;max&#34;: 10},
                                    &#34;highZ&#34;: {&#34;min&#34;: 0.002, &#34;max&#34;: 20}}, &#34;Vpp&#34;)}
            self.arbitrary_waveform_length = [2, 8192]  # min length, max length
            self.arbitrary_waveform_resolution = 16383  # 14 bit
        else:
            msg = (&#34;Model {} not supported, no limits set!&#34;
                   &#34;\n\tTo use the limits for AFG1022, call the class with &#34;
                   &#34;&#39;override_compatibility=True&#39;&#34;
                   &#34;\n\tNote that this might lead to unexpected behaviour &#34;
                   &#34;for custom waveforms and &#39;MIN&#39;/&#39;MAX&#39; keywords.&#34;)
            raise NotCompatibleError(msg)

    def write(self, command, custom_err_message=None):
        &#34;&#34;&#34;Write a VISA command to the instrument

        Parameters
        ----------
        command : str
            The VISA command to be written to the instrument
        custom_err_message : str, default `None`
            When `None`, the RuntimeError message is &#34;Writing/querying command
            {command} failed: pyvisa returned StatusCode ..&#34;.
            Otherwise, if a message is supplied &#34;Could not {message}:
            pyvisa returned StatusCode ..&#34;

        Returns
        -------
        bytes : int
            Number of bytes tranferred

        Raises
        ------
        RuntimeError
            If status returned by PyVISA write command is not
            `pyvisa.constants.StatusCode.success`
        &#34;&#34;&#34;
        num_bytes = self.inst.write(command)
        self.check_pyvisa_status(command, custom_err_message=custom_err_message)
        return num_bytes

    def query(self, command, custom_err_message=None):
        &#34;&#34;&#34;Query the instrument

        Parameters
        ----------
        command : str
            The VISA query command
        custom_err_message : str, default `None`
            When `None`, the RuntimeError message is &#34;Writing/querying command
            {command} failed: pyvisa returned StatusCode ..&#34;.
            Otherwise, if a message is supplied &#34;Could not {message}:
            pyvisa returned StatusCode ..&#34;

        Returns
        -------
        str
            The instrument&#39;s response

        Raises
        ------
        RuntimeError
            If status returned by PyVISA write command is not
            `pyvisa.constants.StatusCode.success`
        &#34;&#34;&#34;
        response = self.inst.query(command).strip()
        self.check_pyvisa_status(command, custom_err_message=custom_err_message)
        return response

    def check_pyvisa_status(self, command, custom_err_message=None):
        &#34;&#34;&#34;Check the last status code of PyVISA

        Parameters
        ----------
        command : str
            The VISA write/query command

        Returns
        -------
        status : pyvisa.constants.StatusCode
            Return value of the library call

        Raises
        ------
        RuntimeError
            If status returned by PyVISA write command is not
            `pyvisa.constants.StatusCode.success`
        &#34;&#34;&#34;
        status = self.inst.last_status
        if not status == pyvisa.constants.StatusCode.success:
            if custom_err_message is not None:
                msg = (&#34;Could not {}: pyvisa returned StatusCode {} &#34;
                       &#34;({})&#34;.format(custom_err_message, status, str(status)))
                raise RuntimeError(msg)
            else:
                msg = (&#34;Writing/querying command {} failed: pyvisa returned StatusCode&#34;
                       &#34; {} ({})&#34;.format(command, status, str(status)))
                raise RuntimeError(msg)
        return status

    def get_error(self):
        &#34;&#34;&#34;Get the contents of the Error/Event queue on the device

        Returns
        -------
        str
            Error/event number, description of error/event
        &#34;&#34;&#34;
        return self.query(&#34;SYSTEM:ERROR:NEXT?&#34;)

    def spawn_channel(self, channel, impedance):
        &#34;&#34;&#34;Wrapper function to create a `FuncGenChannel` object for
        a channel -- see the class docstring&#34;&#34;&#34;
        return FuncGenChannel(self, channel, impedance)

    def get_settings(self):
        &#34;&#34;&#34;Get dictionaries of the current settings of the two channels

        Returns
        -------
        settings : list of dicts
            [ch1_dict, ch2_dict]: Settings currently in use as a dictionary
            with keys output, function, amplitude, offset, and frequency with
            corresponding values
        &#34;&#34;&#34;
        return [ch.get_settings() for ch in self.channels]

    def print_settings(self):
        &#34;&#34;&#34;Prints table of the current setting for both channels&#34;&#34;&#34;
        settings = self.get_settings()
        # Find the necessary padding for the table columns
        # by evaluating the maximum length of the entries
        key_padding = max([len(key) for key in settings[0].keys()])
        ch_paddings = [max([len(str(val[0])) for val in ch_settings.values()])
                       for ch_settings in settings]
        padding = [key_padding]+ch_paddings
        print(&#34;\nCurrent settings for {} {} {}\n&#34;.format(self.maker,
                                                         self.model,
                                                         self.serial))
        row_format = &#34;{:&gt;{padd[0]}s} {:{padd[1]}s} {:{padd[2]}s} {}&#34;
        table_header = row_format.format(&#34;Setting&#34;, &#34;Ch1&#34;, &#34;Ch2&#34;,
                                         &#34;Unit&#34;, padd=padding)
        print(table_header)
        print(&#34;=&#34;*len(table_header))
        for (ch1key, (ch1val, unit)), (_, (ch2val, _)) in zip(settings[0].items(),
                                                              settings[1].items()):
            print(row_format.format(ch1key, str(ch1val), str(ch2val),
                                    unit, padd=padding))

    def set_settings(self, settings):
        &#34;&#34;&#34;Set the settings of both channels with settings dictionaries

        (Each channel is turned off before applying the changes to avoid
        potenitally harmful combinations)

        Parameteres
        -----------
        settings : list of dicts
            List of settings dictionaries as returned by `get_settings`, first
            entry for channel 1, second for channel 2. The dictionaries should
            have keys output, function, amplitude, offset, and frequency
        &#34;&#34;&#34;
        for ch, s in zip(self.channels, settings):
            ch.set_settings(s)

    def syncronise_waveforms(self):
        &#34;&#34;&#34;Syncronise waveforms of the two channels when using the same frequency

        Note: Does NOT enable the frequency lock that can be enabled on the
        user interface of the instrument)
        &#34;&#34;&#34;
        self.write(&#34;:PHAS:INIT&#34;, custom_err_message=&#34;syncronise waveforms&#34;)

    def get_frequency_lock(self):
        &#34;&#34;&#34;Check if frequency lock is enabled

        Returns
        -------
        bool
            `True` if frequency lock enabled
        &#34;&#34;&#34;
        # If one is locked so is the other, so just need to check one
        return int(self.query(&#34;SOURCE1:FREQuency:CONCurrent?&#34;)) == 1

    def set_frequency_lock(self, state, use_channel=1):
        &#34;&#34;&#34;Enable the frequency lock to make the two channels have the same
        frequency and phase of their signals, also after adjustments.

        See also `FuncGen.syncronise_waveforms` for one-time sync only.

        Parameters
        ----------
        state : {&#34;ON&#34;, &#34;OFF&#34;}
            ON to enable, OFF to disable the lock
        use_channel : int, default 1
            Only relevant if turning the lock ON: The channel whose frequency
            shall be used as the common freqency
        &#34;&#34;&#34;
        if self.verbose:
            if state.lower() == &#34;off&#34; and not self.get_frequency_lock():
                print(&#34;(!) {}: Tried to disable frequency lock, but &#34;
                      &#34;frequency lock was not enabled&#34;.format(self.model))
                return
            if state.lower() == &#34;on&#34; and self.get_frequency_lock():
                print(&#34;(!) {}: Tried to enable frequency lock, but &#34;
                      &#34;frequency lock was already enabled&#34;.format(self.model))
                return
        # (Sufficient to disable for only one of the channels)
        cmd = &#34;SOURCE{}:FREQuency:CONCurrent {}&#34;.format(use_channel, state)
        msg = &#34;turn frequency lock {}&#34;.format(state)
        self.write(cmd, custom_err_message=msg)

    def software_trig(self):
        &#34;&#34;&#34;NOT TESTED: sends a trigger signal to the device
        (for bursts or modulations)&#34;&#34;&#34;
        self.write(&#34;*TRG&#34;, custom_err_message=&#34;send trigger signal&#34;)


    ## ~~~~~~~~~~~~~~~~~~~~~ CUSTOM WAVEFORM FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~ ##

    def get_waveform_catalogue(self):
        &#34;&#34;&#34;Get list of the waveforms that are in use (not empty)

        Returns
        -------
        catalogue : list
            Strings with the names of the user functions that are not empty
        &#34;&#34;&#34;
        catalogue = self.query(&#34;DATA:CATalog?&#34;).split(&#34;,&#34;)
        catalogue = [wf[1:-1] for wf in catalogue] # strip off extra quotes
        return catalogue

    def get_custom_waveform(self, memory_num):
        &#34;&#34;&#34;Get the waveform currently stored in USER&lt;memory_num&gt;

        Parameters
        ----------
        memory_num : str or int {0,...,255}, default 0
            Select which user memory to compare with

        Returns
        -------
        waveform : ndarray
            Waveform as ints spanning the resolution of the function gen or
            and empty array if waveform not in use
        &#34;&#34;&#34;
        # Find the wavefroms in use
        waveforms_in_use = self.get_waveform_catalogue()
        if &#34;USER{}&#34;.format(memory_num) in waveforms_in_use:
            # Copy the waveform to edit memory
            self.write(&#34;DATA:COPY EMEMory,USER{}&#34;.format(memory_num))
            # Get the length of the waveform
            waveform_length = int(self.query(&#34;DATA:POINts? EMEMory&#34;))
            # Get the waveform (returns binary values)
            waveform = self.inst.query_binary_values(&#34;DATA:DATA? EMEMory&#34;,
                                                     datatype=&#39;H&#39;,
                                                     is_big_endian=True,
                                                     container=np.ndarray)
            msg = (&#34;Waveform length from native length command (DATA:POINts?) &#34;
                   &#34;and the processed binary values do not match, {} and {} &#34;
                   &#34;respectively&#34;.format(waveform_length, len(waveform)))
            assert len(waveform) == waveform_length, msg
            return waveform
        else:
            print(&#34;Waveform USER{} is not in use&#34;.format(memory_num))
            return np.array([])

    def set_custom_waveform(self, waveform, normalise=True, memory_num=0,
                            verify=True, print_progress=True):
        &#34;&#34;&#34;Transfer waveform data to edit memory and then user memory.
        NOTE: Will overwrite without warnings

        Parameters
        ----------
        waveform : ndarray
            Either unnormalised arbitrary waveform (then use `normalise=True`),
            or ints spanning the resolution of the function generator
        normalise : bool
            Choose whether to normalise the waveform to ints over the
            resolution span of the function generator
        memory_num : str or int {0,...,255}, default 0
            Select which user memory to copy to
        verify : bool, default `True`
            Verify that the waveform has been transferred and is what was sent
        print_progress : bool, default `True`

        Returns
        -------
        waveform : ndarray
            The normalised waveform transferred

        Raises
        ------
        ValueError
            If the waveform is not within the permitted length or value range
        RuntimeError
            If the waveform transferred to the instrument is of a different
            length than the waveform supplied
        &#34;&#34;&#34;
        # Check if waveform data is suitable
        if print_progress:
            print(&#34;Check if waveform data is suitable..&#34;, end=&#34; &#34;)
        self.check_arb_waveform_length(waveform)
        try:
            self.check_arb_waveform_type_and_range(waveform)
        except ValueError as e:
            if print_progress:
                print(&#34;\n  &#34;+str(e))
                print(&#34;Trying again normalising the waveform..&#34;, end=&#34; &#34;)
            waveform = self.normalise_to_waveform(waveform)
        if print_progress:
            print(&#34;ok&#34;)
            print(&#34;Transfer waveform to function generator..&#34;, end=&#34; &#34;)
        # Transfer waveform
        self.inst.write_binary_values(&#34;DATA:DATA EMEMory,&#34;, waveform,
                                      datatype=&#39;H&#39;, is_big_endian=True)
        # The first query after the write_binary_values returns &#39;&#39;,
        # so here is a mock query
        self.query(&#34;&#34;)
        transfer_error = self.get_error()
        emem_wf_length = self.query(&#34;DATA:POINts? EMEMory&#34;)
        if emem_wf_length == &#39;&#39; or not int(emem_wf_length) == len(waveform):
            msg = (&#34;Waveform in temporary EMEMory has a length of {}, not of &#34;
                   &#34;the same length as the waveform ({}).\nError from the &#34;
                   &#34;instrument: {}&#34;.format(emem_wf_length, len(waveform),
                                           transfer_error))
            raise RuntimeError(msg)
        if print_progress:
            print(&#34;ok&#34;)
            print(&#34;Copy waveform to USER{}..&#34;.format(memory_num), end=&#34; &#34;)
        self.write(&#34;DATA:COPY USER{},EMEMory&#34;.format(memory_num))
        if print_progress:
            print(&#34;ok&#34;)
        if verify:
            if print_progress:
                print(&#34;Verify waveform USER{}..&#34;.format(memory_num))
            if &#34;USER{}&#34;.format(memory_num) in self.get_waveform_catalogue():
                self.verify_waveform(waveform, memory_num, normalise=normalise,
                                     print_result=print_progress)
            else:
                print(&#34;(!) USER{} is empty&#34;.format(memory_num))
        return waveform

    def normalise_to_waveform(self, shape):
        &#34;&#34;&#34;Normalise a shape of any discretisation and range to a waveform that
        can be transmitted to the function generator

        .. note::
            If you are transferring a flat/constant waveform, do not use this
            normaisation function. Transfer a waveform like
            `int(self.arbitrary_waveform_resolution/2)*np.ones(2).astype(np.int32)`
            without normalising for a well behaved flat function.

        Parameters
        ----------
        shape : array_like
            Array to be transformed to waveform, can be ints or floats,
            any normalisation or discretisation

        Returns
        -------
        waveform : ndarray
            Waveform as ints spanning the resolution of the function gen
        &#34;&#34;&#34;
        # Check if waveform data is suitable
        self.check_arb_waveform_length(shape)
        # Normalise
        waveform = shape - np.min(shape)
        normalisation_factor = np.max(waveform)
        waveform = waveform/normalisation_factor*self.arbitrary_waveform_resolution
        return waveform.astype(np.uint16)

    def verify_waveform(self, waveform, memory_num, normalise=True,
                        print_result=True):
        &#34;&#34;&#34;Compare a waveform in user memory to argument waveform

        Parameters
        ----------
        waveform : ndarray
            Waveform as ints spanning the resolution of the function gen
        memory_num : str or int {0,...,255}, default 0
            Select which user memory to compare with
        normalise : bool, default `True`
            Normalise test waveform

        Returns
        -------
        bool
            Boolean according to equal/not equal
        instrument_waveform
            The waveform on the instrument
        list or `None`
            List of the indices where the waveforms are not equal or `None` if
            the waveforms were of different lengths
        &#34;&#34;&#34;
        if normalise: # make sure test waveform is normalised
            waveform = self.normalise_to_waveform(waveform)
        # Get the waveform on the instrument
        instrument_waveform = self.get_custom_waveform(memory_num)
        # Compare lengths
        len_inst_wav, len_wav = len(instrument_waveform), len(waveform)
        if not len_inst_wav == len_wav:
            if print_result:
                print(&#34;The waveform in USER{} and the compared waveform are &#34;
                      &#34;not of same length (instrument {} vs {})&#34;
                      &#34;&#34;.format(memory_num, len_inst_wav, len_wav))
            return False, instrument_waveform, None
        # Compare each element
        not_equal = []
        for i in range(len_wav):
            if not instrument_waveform[i] == waveform[i]:
                not_equal.append(i)
        # Return depending of whether list is empty or not
        if not not_equal: # if list is empty
            if print_result:
                print(&#34;The waveform in USER{} and the compared waveform &#34;
                      &#34;are equal&#34;.format(memory_num))
            return True, instrument_waveform, not_equal
        if print_result:
            print(&#34;The waveform in USER{} and the compared waveform are &#34;
                  &#34;NOT equal&#34;.format(memory_num))
        return False, instrument_waveform, not_equal

    def check_arb_waveform_length(self, waveform):
        &#34;&#34;&#34;Checks if waveform is within the acceptable length

        Parameters
        ----------
        waveform : array_like
            Waveform or voltage list to be checked

        Raises
        ------
        ValueError
            If the waveform is not within the permitted length
        &#34;&#34;&#34;
        if ((len(waveform) &lt; self.arbitrary_waveform_length[0]) or
            (len(waveform) &gt; self.arbitrary_waveform_length[1])):
            msg = (&#34;The waveform is of length {}, which is not within the &#34;
                   &#34;acceptable length {} &lt; len &lt; {}&#34;
                   &#34;&#34;.format(len(waveform), *self.arbitrary_waveform_length))
            raise ValueError(msg)

    def check_arb_waveform_type_and_range(self, waveform):
        &#34;&#34;&#34;Checks if waveform is of int/np.int32 type and within the resolution
        of the function generator

        Parameters
        ----------
        waveform : array_like
            Waveform or voltage list to be checked

        Raises
        ------
        ValueError
            If the waveform values are not int, np.uint16 or np.int32, or the
            values are not within the permitted range
        &#34;&#34;&#34;
        for value in waveform:
            if not isinstance(value, (int, np.uint16, np.int32)):
                raise ValueError(&#34;The waveform contains values that are not&#34;
                                 &#34;int, np.uint16 or np.int32&#34;)
            if (value &lt; 0) or (value &gt; self.arbitrary_waveform_resolution):
                raise ValueError(&#34;The waveform contains values out of range &#34;
                                 &#34;({} is not within the resolution &#34;
                                 &#34;[0, {}])&#34;.format(value,
                                        self.arbitrary_waveform_resolution))


## ~~~~~~~~~~~~~~~~~~~~~~~ CHANNEL CLASS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##

class FuncGenChannel:
    &#34;&#34;&#34;Class for controlling a channel on a function generator object

    Parameters
    ----------
    fgen : `FuncGen`
        The function generator object
    channel : {1, 2}
        The channel to be controlled
    impedance : {&#34;50ohm&#34;, &#34;highZ&#34;}
        Determines voltage limits associated with high impedance (whether the
        instrument is using 50ohm or high Z cannot be controlled through VISA)

    Attributes
    ----------
    fgen : `FuncGen`
        The function generator object for which the channel exists
    channel : {1, 2}
        The channel number
    impedance : {&#34;50ohm&#34;, &#34;highZ&#34;}
        Determines voltage limits associated with high impedance (whether the
        instrument is using 50ohm or high Z cannot be controlled through VISA)
    source : str
        &#34;SOURce{}:&#34; where {} is the channel number
    settings_units : list
        The units for the settings produced by `FuncGenChannel.get_settings`
    state_str : dict
        For conversion from states 1 and 2 to &#34;ON&#34; and &#34;OFF&#34;
    &#34;&#34;&#34;

    # Attributes
    state_str = {&#34;1&#34;: &#34;ON&#34;, &#34;0&#34;: &#34;OFF&#34;,
                  1 : &#34;ON&#34;,  0 : &#34;OFF&#34;}
    &#34;&#34;&#34;Dictionary for converting output states to &#34;ON&#34; and &#34;OFF&#34; &#34;&#34;&#34;

    def __init__(self, fgen, channel, impedance):
        self.fgen = fgen
        self.channel = channel
        self.source = &#34;SOURce{}:&#34;.format(channel)
        self.impedance = impedance
        # Adopt limits dictionary from instrument
        self.channel_limits = copy.deepcopy(self.fgen.instrument_limits)

    def impedance_dependent_limit(self, limit_type):
        &#34;&#34;&#34;Check if the limit type is impedance dependent (voltages) or
        not (frequency)

        Returns
        -------
        bool
            `True` if the limit is impedance dependent
        &#34;&#34;&#34;
        try: # to access the key &#34;min&#34; to check if impedance must be selected
            _ = self.channel_limits[limit_type][0][&#34;min&#34;]
            return False
        except KeyError: # if the key does not exist
            # The impedance must be selected
            return True

    def set_stricter_limits(self):
        &#34;&#34;&#34;Set limits for the voltage and frequency limits of the channel output
        through a series of prompts&#34;&#34;&#34;
        print(&#34;Set stricter voltage and frequency limits &#34;
              &#34;for channel {}&#34;.format(self.channel))
        print(&#34;Use enter only to leave a limit unchanged.&#34;)
        # Go through the different limits in the instrument_limits dict
        for limit_type, (inst_limit_dict, unit) in self.fgen.instrument_limits.items():
            use_impedance = self.impedance_dependent_limit(limit_type)
            print(&#34;Set {} in {}&#34;.format(limit_type, unit), end=&#34; &#34;)
            if use_impedance:
                inst_limit_dict = inst_limit_dict[self.impedance]
                print(&#34;[{} impedance limit]&#34;.format(self.impedance))
            else:
                print(&#34;&#34;) # get new line
            # Go through the min and max for the limit type
            for key, inst_value in inst_limit_dict.items():
                # prompt for new value
                new_value = input(&#34;  {} (instrument limit {}{}): &#34;
                                  &#34;&#34;.format(key, inst_value, unit))
                if new_value == &#34;&#34;:
                    # Do not change if empty
                    print(&#34;\tLimit not changed&#34;)
                else:
                    try: # to convert to float
                        new_value = float(new_value)
                    except ValueError:
                        print(&#34;\tLimit unchanged: Could not convert \&#39;{}\&#39; &#34;
                              &#34;to float&#34;.format(new_value))
                        continue # to next item in dict
                    # Set the new limit
                    self.set_limit(limit_type, key, new_value, verbose=True)

    def set_limit(self, limit_type, bound, new_value, verbose=False):
        &#34;&#34;&#34;Set a limit if the new value is within the instrument limits and are
        self consistent (max larger than min)

        Parameterers
        ------------
        limit_type : str
            The name of the limit in the channel_limits dictionary
        bound : {&#34;min&#34;, &#34;max&#34;}
            Specifies if it is the max or the min limit that is to be set
        new_value : float
            The new value to be used for the limit
        verbose : bool
            Print confirmation that the limit was set or reason for why the
            limit was not set

        Returns
        -------
        bool
            `True` if new limit set, `False` otherwise
        &#34;&#34;&#34;
        # Short hand references
        inst_limit_dict = self.fgen.instrument_limits[limit_type]
        channel_limit_dict = self.channel_limits[limit_type]
        # Find the instrument limit and unit
        use_impedance = self.impedance_dependent_limit(limit_type)
        if use_impedance:
            inst_value = inst_limit_dict[0][self.impedance][bound]
        else:
            inst_value = inst_limit_dict[0][bound]
        unit = inst_limit_dict[1]
        # Check that the new value is within the intrument limits
        acceptable_min = bound == &#34;min&#34; and new_value &gt; inst_value
        if use_impedance:
            current_min = channel_limit_dict[0][self.impedance][&#34;min&#34;]
        else:
            current_min = channel_limit_dict[0][&#34;min&#34;]
        larger_than_min = new_value &gt; current_min
        acceptable_max = bound == &#34;max&#34; and new_value &lt; inst_value and larger_than_min
        if acceptable_min or acceptable_max: # within the limits
            # Set the new channel_limit, using the impedance depending on the
            # limit type. Beware that the shorthand cannot be used, as this
            # only changes the shorthand not the dictionary itself
            if use_impedance:
                self.channel_limits[limit_type][0][self.impedance][bound] = new_value
            else:
                self.channel_limits[limit_type][0][bound] = new_value
            if verbose:
                print(&#34;\tNew limit set {}{}&#34;.format(new_value, unit))
            return True
        elif verbose: # print description of why the limit was not set
            if larger_than_min:
                reason = &#34;larger&#34; if bound == &#34;max&#34; else &#34;smaller&#34;
                print(&#34;\tNew limit NOT set: {}{unit} is {} than the instrument &#34;
                      &#34;limit ({}{unit})&#34;.format(new_value, reason, inst_value,
                                                unit=unit))
            else:
                print(&#34;\tNew limit NOT set: {}{unit} is smaller than the &#34;
                      &#34;current set minimum ({}{unit})&#34;.format(new_value,
                                                              current_min,
                                                              unit=unit))
        return False

    # Get currently used parameters from function generator
    def get_output_state(self):
        &#34;&#34;&#34;Returns &#34;0&#34; for &#34;OFF&#34;, &#34;1&#34; for &#34;ON&#34; &#34;&#34;&#34;
        return self.fgen.query(&#34;OUTPut{}:STATe?&#34;.format(self.channel))

    def get_function(self):
        &#34;&#34;&#34;Returns string of function name&#34;&#34;&#34;
        return self.fgen.query(&#34;{}FUNCtion:SHAPe?&#34;.format(self.source))

    def get_amplitude(self):
        &#34;&#34;&#34;Returns peak-to-peak voltage in volts&#34;&#34;&#34;
        return float(self.fgen.query(&#34;{}VOLTage:AMPLitude?&#34;.format(self.source)))

    def get_offset(self):
        &#34;&#34;&#34;Returns offset voltage in volts&#34;&#34;&#34;
        return float(self.fgen.query(&#34;{}VOLTage:OFFSet?&#34;.format(self.source)))

    def get_frequency(self):
        &#34;&#34;&#34;Returns frequency in Hertz&#34;&#34;&#34;
        return float(self.fgen.query(&#34;{}FREQuency?&#34;.format(self.source)))

    # Get limits set in the channel class
    def get_frequency_lims(self):
        &#34;&#34;&#34;Returns list of min and max frequency limits&#34;&#34;&#34;
        return [self.channel_limits[&#34;frequency lims&#34;][0][key]
                for key in [&#34;min&#34;, &#34;max&#34;]]

    def get_voltage_lims(self):
        &#34;&#34;&#34;Returns list of min and max voltage limits for the current impedance&#34;&#34;&#34;
        return [self.channel_limits[&#34;voltage lims&#34;][0][self.impedance][key]
                for key in [&#34;min&#34;, &#34;max&#34;]]

    def get_amplitude_lims(self):
        &#34;&#34;&#34;Returns list of min and max amplitude limits for the current impedance&#34;&#34;&#34;
        return [self.channel_limits[&#34;amplitude lims&#34;][0][self.impedance][key]
                for key in [&#34;min&#34;, &#34;max&#34;]]

    def get_settings(self):
        &#34;&#34;&#34;Get the settings for the channel

        Returns
        -------
        current_settings : dict
            Settings currently in use as a dictionary with keys output,
            function, amplitude, offset, and frequency and values tuples of
            the corresponding return and unit
        &#34;&#34;&#34;
        return {&#34;output&#34;:    (self.state_str[self.get_output_state()], &#34;&#34;),
                &#34;function&#34;:  (self.get_function(),  &#34;&#34;),
                &#34;amplitude&#34;: (self.get_amplitude(), &#34;Vpp&#34;),
                &#34;offset&#34;:    (self.get_offset(),    &#34;V&#34;),
                &#34;frequency&#34;: (self.get_frequency(), &#34;Hz&#34;)}

    def print_settings(self):
        &#34;&#34;&#34;Print the settings currently in use for the channel (Recommended
        to use the `FuncGen.print_settings` for printing both channels)
        &#34;&#34;&#34;
        settings = self.get_settings()
        longest_key = max([len(key) for key in settings.keys()])
        print(&#34;\nCurrent settings for channel {}&#34;.format(self.channel))
        print(&#34;==============================&#34;)
        for key, (val, unit) in settings.items():
            print(&#34;{:&gt;{num_char}s} {} {}&#34;.format(key, val, unit,
                                                 num_char=longest_key))

    def set_settings(self, settings):
        &#34;&#34;&#34;Set the settings of the channel with a settings dictionary. Will
        set the outout to OFF before applyign the settings (and turn the
        channel ON or leave it OFF depending on the settings dict)

        Parameteres
        -----------
        settings : dict
            Settings dictionary as returned by `get_settings`: should have
            keys output, function, amplitude, offset, and frequency
        &#34;&#34;&#34;
        # First turn off to ensure no potentially harmful
        # combination of settings
        self.set_output_state(&#34;OFF&#34;)
        # Set settings according to dictionary
        self.set_function(settings[&#39;function&#39;][0])
        self.set_amplitude(settings[&#39;amplitude&#39;][0])
        self.set_offset(settings[&#39;offset&#39;][0])
        self.set_frequency(settings[&#39;frequency&#39;][0])
        self.set_output_state(settings[&#39;output&#39;][0])

    def set_output_state(self, state):
        &#34;&#34;&#34;Enables or diables the output of the channel

        Parameters
        ----------
        state : int or str
            &#34;ON&#34; or int 1 to enable
            &#34;OFF&#34; or int 0 to disable

        Raises
        ------
        NotSetError
            If `self.fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        err_msg = &#34;turn channel {} to state {}&#34;.format(self.channel, state)
        self.fgen.write(&#34;OUTPut{}:STATe {}&#34;.format(self.channel, state),
                                            custom_err_message=err_msg)
        if self.fgen.verify_param_set:
            actual_state = self.get_output_state()
            if not actual_state == state:
                msg = (&#34;Channel {} was not turned {}, it is {}.\n&#34;
                       &#34;Error from the instrument: {}&#34;
                       &#34;&#34;.format(self.channel, state,
                                 self.state_str[actual_state],
                                 self.fgen.get_error()))
                raise NotSetError(msg)

    def get_output(self):
        &#34;&#34;&#34;Wrapper for get_output_state&#34;&#34;&#34;
        return self.get_output_state()

    def set_output(self, state):
        &#34;&#34;&#34;Wrapper for set_output_state&#34;&#34;&#34;
        self.set_output_state(state)

    def set_function(self, shape):
        &#34;&#34;&#34;Set the function shape of the output

        Parameters
        ----------
        shape : {SINusoid, SQUare, PULSe, RAMP, PRNoise, &lt;Built_in&gt;, USER[0],
                 USER1, ..., USER255, EMEMory, EFILe}
            &lt;Built_in&gt;::={StairDown|StairUp|Stair Up&amp;Dwn|Trapezoid|RoundHalf|
            AbsSine|AbsHalfSine|ClippedSine|ChoppedSine|NegRamp|OscRise|
            OscDecay|CodedPulse|PosPulse|NegPulse|ExpRise|ExpDecay|Sinc|
            Tan|Cotan|SquareRoot|X^2|HaverSine|Lorentz|Ln(x)|X^3|CauchyDistr|
            BesselJ|BesselY|ErrorFunc|Airy|Rectangle|Gauss|Hamming|Hanning|
            Bartlett|Blackman|Laylight|Triangle|DC|Heart|Round|Chirp|Rhombus|
            Cardiac}

        Raises
        ------
        NotSetError
            If `self.fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        cmd = &#34;{}FUNCtion:SHAPe {}&#34;.format(self.source, shape)
        self.fgen.write(cmd, custom_err_message=&#34;set function {}&#34;.format(shape))
        if self.fgen.verify_param_set:
            actual_shape = self.get_function()
            if not actual_shape == shape:
                msg = (&#34;Function {} was not set on channel {}, it is {}. &#34;
                       &#34;Check that the function name is correctly spelt. &#34;
                       &#34;Run set_function.__doc__ to see available shapes.\n&#34;
                       &#34;Error from the instrument: {}&#34;
                       &#34;&#34;.format(shape, self.channel, actual_shape,
                                 self.fgen.get_error()))
                raise NotSetError(msg)

    def set_amplitude(self, amplitude):
        &#34;&#34;&#34;Set the peak-to-peak amplitude in volts

        Parameters
        ----------
        amplitude : float or {&#34;max&#34;, &#34;min&#34;}
            0.1mV or four digits resolution, &#34;max&#34; or &#34;min&#34; will set the
            amplitude to the maximum or minimum limit given in `channel_limits`

        Raises
        ------
        NotSetError
            If `self.fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        # Check if keyword min or max is given
        if str(amplitude).lower() in [&#34;min&#34;, &#34;max&#34;]:
            unit = &#34;&#34; # no unit for MIN/MAX
            # Look up what the limit is for this keyword
            amplitude = self.channel_limits[&#34;amplitude lims&#34;][0][self.impedance][str(amplitude).lower()]
        else:
            unit = &#34;Vpp&#34;
            # Check if the given amplitude is within the current limits
            min_ampl, max_ampl = self.get_amplitude_lims()
            if amplitude &lt; min_ampl or amplitude &gt; max_ampl:
                msg = (&#34;Could not set the amplitude {}{unit} as it is not &#34;
                       &#34;within the amplitude limits set for the instrument &#34;
                       &#34;[{}, {}]{unit}&#34;.format(amplitude, min_ampl, max_ampl,
                                               unit=unit))
                raise NotSetError(msg)
        # Check that the new amplitude will not violate voltage limits
        min_volt, max_volt = self.get_voltage_lims()
        current_offset = self.get_offset()
        if (amplitude/2-current_offset &lt; min_volt or
            amplitude/2+current_offset &gt; max_volt):
            msg = (&#34;Could not set the amplitude {}{unit} as the amplitude &#34;
                   &#34;combined with the offset ({}V) will be outside the &#34;
                   &#34;absolute voltage limits [{}, {}]{unit}&#34;
                   &#34;&#34;.format(amplitude, current_offset, min_volt, max_volt,
                             unit=unit))
            raise NotSetError(msg)
        # Set the amplitude
        cmd = &#34;{}VOLTage:LEVel {}{}&#34;.format(self.source, amplitude, unit)
        err_msg = &#34;set amplitude {}{}&#34;.format(amplitude, unit)
        self.fgen.write(cmd, custom_err_message=err_msg)
        # Verify that the amplitude has been set
        if self.fgen.verify_param_set:
            actual_amplitude = self.get_amplitude()
            # Multiply with the appropriate factor according to SI prefix, or
            # if string is empty, use the value looked up from channel_limits earlier
            if not unit == &#34;&#34;:
                check_amplitude = amplitude*self.SI_prefix_to_factor(unit)
            else:
                 check_amplitude = amplitude
            if not actual_amplitude == check_amplitude:
                msg = (&#34;Amplitude {}{} was not set on channel {}, it is &#34;
                       &#34;{}Vpp. Check that the number is within the possible &#34;
                       &#34;range and in the correct format.\nError from the &#34;
                       &#34;instrument: {}&#34;
                       &#34;&#34;.format(amplitude, unit, self.channel,
                                 actual_amplitude, self.fgen.get_error()))
                raise NotSetError(msg)

    def set_offset(self, offset, unit=&#34;V&#34;):
        &#34;&#34;&#34;Set offset in volts (or mV, see options)

        Parameters
        ----------
        offset : float
            Unknown resolution, guessing 0.1mV or four digits resolution
        unit : {mV, V}, default V

        Raises
        ------
        NotSetError
            If `self.fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        # Check that the new offset will not violate voltage limits
        min_volt, max_volt = self.get_voltage_lims()
        current_amplitude = self.get_amplitude()
        if (current_amplitude/2-offset &lt; min_volt or
            current_amplitude/2+offset &gt; max_volt):
            msg = (&#34;Could not set the offset {}{unit} as the offset combined&#34;
                   &#34;with the amplitude ({}V) will be outside the absolute &#34;
                   &#34;voltage limits [{}, {}]{unit}&#34;.format(offset,
                                                         current_amplitude,
                                                         min_volt, max_volt,
                                                         unit=unit))
            raise NotSetError(msg)
        # Set the offset
        cmd = &#34;{}VOLTage:LEVel:OFFSet {}{}&#34;.format(self.source, offset, unit)
        err_msg = &#34;set offset {}{}&#34;.format(offset, unit)
        self.fgen.write(cmd, custom_err_message=err_msg)
        # Verify that the offset has been set
        if self.fgen.verify_param_set:
            actual_offset = self.get_offset()
            # Multiply with the appropriate factor according to SI prefix
            check_offset = offset*self.SI_prefix_to_factor(unit)
            if not actual_offset == check_offset:
                msg = (&#34;Offset {}{} was not set on channel {}, it is {}V. &#34;
                       &#34;Check that the number is within the possible range and &#34;
                       &#34;in the correct format.\nError from the instrument: {}&#34;
                       &#34;&#34;.format(offset, unit, self.channel, actual_offset,
                                 self.fgen.get_error()))
                raise NotSetError(msg)

    def set_frequency(self, freq, unit=&#34;Hz&#34;):
        &#34;&#34;&#34;Set the frequency in Hertz (or kHz, MHz, see options)

        Parameters
        ----------
        freq : float
            The resolution is 1 Î¼Hz or 12 digits.
        unit : {Hz, kHz, MHz}, default Hz

        Raises
        ------
        NotSetError
            If `self.fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        if str(freq).lower() in [&#34;min&#34;, &#34;max&#34;]: # handle min and max keywords
            unit = &#34;&#34; # no unit for MIN/MAX
            # Look up what the limit is for this keyword
            freq = self.channel_limits[&#34;frequency lims&#34;][0][str(freq).lower()]
        else:
            # Check if the given frequency is within the current limits
            min_freq, max_freq = self.get_frequency_lims()
            if freq &lt; min_freq or freq &gt; max_freq:
                msg = (&#34;Could not set the frequency {}{} as it is not within &#34;
                       &#34;the frequency limits set for the instrument [{}, {}]&#34;
                       &#34;Hz&#34;.format(freq, unit, min_freq, max_freq))
                raise NotSetError(msg)
        # Check that the new amplitude will not violate voltage limits
        min_volt, max_volt = self.get_voltage_lims()
        # Set the frequency
        self.fgen.write(&#34;{}FREQuency:FIXed {}{}&#34;.format(self.source, freq, unit),
                            custom_err_message=&#34;set frequency {}{}&#34;.format(freq, unit))
        # Verify that the amplitude has been set
        if self.fgen.verify_param_set:
            actual_freq = self.get_frequency()
            # Multiply with the appropriate factor according to SI prefix, or
            # if string is empty, use the value looked up from channel_limits earlier
            if not unit == &#34;&#34;:
                check_freq = freq*self.SI_prefix_to_factor(unit)
            else:
                check_freq =  freq
            if not actual_freq == check_freq:
                msg = (&#34;Frequency {}{} was not set on channel {}, it is {}Hz. &#34;
                &#34;Check that the number is within the possible range and in &#34;
                &#34;the correct format.\nError from the instrument: {}&#34;
                &#34;&#34;.format(freq, unit, self.channel, actual_freq,
                            self.fgen.get_error()))
                raise NotSetError(msg)


    ## ~~~~~~~~~~~~~~~~~~~~~~~ AUXILLIARY ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##

    @staticmethod
    def SI_prefix_to_factor(unit):
        &#34;&#34;&#34;Convert an SI prefix to a numerical factor

        Parameters
        ----------
        unit : str
            The unit whose first character is checked against the list of
            prefactors {&#34;M&#34;: 1e6, &#34;k&#34;: 1e3, &#34;m&#34;: 1e-3}

        Returns
        -------
        factor : float or `None`
            The appropriate factor or 1 if not found in the list, or `None`
            if the unit string is empty
        &#34;&#34;&#34;
        # SI prefix to numerical value
        SI_conversion = {&#34;M&#34;:1e6, &#34;k&#34;:1e3, &#34;m&#34;:1e-3}
        try:  # using the unit&#39;s first character as key in the dictionary
            factor = SI_conversion[unit[0]]
        except KeyError:  # if the entry does not exist
            factor = 1
        except IndexError:  # if the unit string is empty
            factor = None
        return factor


## ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ERROR CLASSES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##

class NotSetError(Exception):
    &#34;&#34;&#34;Error for when a value cannot be written to the instrument&#34;&#34;&#34;


class NotCompatibleError(Exception):
    &#34;&#34;&#34;Error for when the instrument is not compatible with this module&#34;&#34;&#34;


## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ EXAMPLES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##

def example_basic_control(address):
    &#34;&#34;&#34;Example showing how to connect, and the most basic control of the
    instrument parameteres&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_basic_control.__doc__)
    with FuncGen(address) as fgen:
      fgen.ch1.set_function(&#34;SIN&#34;)
      fgen.ch1.set_frequency(25, unit=&#34;Hz&#34;)
      fgen.ch1.set_offset(50, unit=&#34;mV&#34;)
      fgen.ch1.set_amplitude(0.002)
      fgen.ch1.set_output(&#34;ON&#34;)
      fgen.ch2.set_output(&#34;OFF&#34;)
      # Alternatively fgen.ch1.print_settings() to show from one channel only
      fgen.print_settings()


def example_change_settings(address):
    &#34;&#34;&#34;Example showing how to get the current settings of the instrument,
    store them, change a setting and then restore the initial settings&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_change_settings.__doc__)
    with FuncGen(address) as fgen:
        fgen.print_settings()
        print(&#34;Saving these settings..&#34;)
        settings = fgen.get_settings()
        print(&#34;Change to 1Vpp amplitude for channel 1..&#34;)
        fgen.ch1.set_amplitude(1)
        fgen.print_settings()
        print(&#34;Reset back to initial settings..&#34;)
        fgen.set_settings(settings)
        fgen.print_settings()


def example_lock_frequencies(address):
    &#34;&#34;&#34;Example showing the frequency being set to 10Hz and then the frequency
    lock enabled, using the frequency at ch1 as the common frequency&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_lock_frequencies.__doc__)
    with FuncGen(address, verbose=False) as fgen:
        fgen.ch1.set_frequency(10)
        fgen.set_frequency_lock(&#34;ON&#34;, use_channel=1)


def example_changing_limits(address):
    &#34;&#34;&#34;Example showing how limits can be read and changed&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_changing_limits.__doc__)
    with FuncGen(address) as fgen:
        lims = fgen.ch1.get_frequency_lims()
        print(&#34;Channel 1 frequency limits: {}&#34;.format(lims))
        print(&#34;Change the lower limit to 2Hz..&#34;)
        fgen.ch1.set_limit(&#34;frequency lims&#34;, &#34;min&#34;, 2)
        lims = fgen.ch1.get_frequency_lims()
        print(&#34;Channel 1 frequency limits: {}&#34;.format(lims))
        print(&#34;Try to set ch1 frequency to 1Hz..&#34;)
        try:
            fgen.ch1.set_frequency(1)
        except NotSetError as err:
            print(err)


def example_set_and_use_custom_waveform(fgen=None, address=None, channel=1,
                                        plot_signal=True):
    &#34;&#34;&#34;Example showing a waveform being created, transferred to the instrument,
    and applied to a channel&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_set_and_use_custom_waveform.__doc__)
    # Create a signal
    x = np.linspace(0, 4*np.pi, 8000)
    signal = np.sin(x)+x/5
    if plot_signal: # plot the signal for visual control
        import matplotlib.pyplot as plt
        plt.plot(signal)
        plt.show()
    # Create initialise fgen if it was not supplied
    if fgen is None:
        fgen = FuncGen(address)
        close_fgen = True # specify that it should be closed at end of function
    else:
        close_fgen = False # do not close the supplied fgen at end
    print(&#34;Current waveform catalogue&#34;)
    for i, wav in enumerate(fgen.get_waveform_catalogue()):
        print(&#34;  {}: {}&#34;.format(i, wav))
    # Transfer the waveform
    fgen.set_custom_waveform(signal, memory_num=5, verify=True)
    print(&#34;New waveform catalogue:&#34;)
    for i, wav in enumerate(fgen.get_waveform_catalogue()):
        print(&#34;  {}: {}&#34;.format(i, wav))
    print(&#34;Set new wavefrom to channel {}..&#34;.format(channel), end=&#34; &#34;)
    fgen.channels[channel-1].set_output_state(&#34;OFF&#34;)
    fgen.channels[channel-1].set_function(&#34;USER5&#34;)
    print(&#34;ok&#34;)
    # Print current settings
    fgen.get_settings()
    if close_fgen: fgen.close()


## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MAIN FUNCTION ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##

if __name__ == &#39;__main__&#39;:
    address = &#39;USB0::0x0699::0x0353::1731975::INSTR&#39;
    example_basic_control(address)
    example_change_settings(address)
    example_lock_frequencies(address)
    example_changing_limits(address)
    with FuncGen(address) as fgen:
        example_set_and_use_custom_waveform(fgen)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tektronix_func_gen.example_basic_control"><code class="name flex">
<span>def <span class="ident">example_basic_control</span></span>(<span>address)</span>
</code></dt>
<dd>
<section class="desc"><p>Example showing how to connect, and the most basic control of the
instrument parameteres</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def example_basic_control(address):
    &#34;&#34;&#34;Example showing how to connect, and the most basic control of the
    instrument parameteres&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_basic_control.__doc__)
    with FuncGen(address) as fgen:
      fgen.ch1.set_function(&#34;SIN&#34;)
      fgen.ch1.set_frequency(25, unit=&#34;Hz&#34;)
      fgen.ch1.set_offset(50, unit=&#34;mV&#34;)
      fgen.ch1.set_amplitude(0.002)
      fgen.ch1.set_output(&#34;ON&#34;)
      fgen.ch2.set_output(&#34;OFF&#34;)
      # Alternatively fgen.ch1.print_settings() to show from one channel only
      fgen.print_settings()</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.example_change_settings"><code class="name flex">
<span>def <span class="ident">example_change_settings</span></span>(<span>address)</span>
</code></dt>
<dd>
<section class="desc"><p>Example showing how to get the current settings of the instrument,
store them, change a setting and then restore the initial settings</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def example_change_settings(address):
    &#34;&#34;&#34;Example showing how to get the current settings of the instrument,
    store them, change a setting and then restore the initial settings&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_change_settings.__doc__)
    with FuncGen(address) as fgen:
        fgen.print_settings()
        print(&#34;Saving these settings..&#34;)
        settings = fgen.get_settings()
        print(&#34;Change to 1Vpp amplitude for channel 1..&#34;)
        fgen.ch1.set_amplitude(1)
        fgen.print_settings()
        print(&#34;Reset back to initial settings..&#34;)
        fgen.set_settings(settings)
        fgen.print_settings()</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.example_changing_limits"><code class="name flex">
<span>def <span class="ident">example_changing_limits</span></span>(<span>address)</span>
</code></dt>
<dd>
<section class="desc"><p>Example showing how limits can be read and changed</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def example_changing_limits(address):
    &#34;&#34;&#34;Example showing how limits can be read and changed&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_changing_limits.__doc__)
    with FuncGen(address) as fgen:
        lims = fgen.ch1.get_frequency_lims()
        print(&#34;Channel 1 frequency limits: {}&#34;.format(lims))
        print(&#34;Change the lower limit to 2Hz..&#34;)
        fgen.ch1.set_limit(&#34;frequency lims&#34;, &#34;min&#34;, 2)
        lims = fgen.ch1.get_frequency_lims()
        print(&#34;Channel 1 frequency limits: {}&#34;.format(lims))
        print(&#34;Try to set ch1 frequency to 1Hz..&#34;)
        try:
            fgen.ch1.set_frequency(1)
        except NotSetError as err:
            print(err)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.example_lock_frequencies"><code class="name flex">
<span>def <span class="ident">example_lock_frequencies</span></span>(<span>address)</span>
</code></dt>
<dd>
<section class="desc"><p>Example showing the frequency being set to 10Hz and then the frequency
lock enabled, using the frequency at ch1 as the common frequency</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def example_lock_frequencies(address):
    &#34;&#34;&#34;Example showing the frequency being set to 10Hz and then the frequency
    lock enabled, using the frequency at ch1 as the common frequency&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_lock_frequencies.__doc__)
    with FuncGen(address, verbose=False) as fgen:
        fgen.ch1.set_frequency(10)
        fgen.set_frequency_lock(&#34;ON&#34;, use_channel=1)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.example_set_and_use_custom_waveform"><code class="name flex">
<span>def <span class="ident">example_set_and_use_custom_waveform</span></span>(<span>fgen=None, address=None, channel=1, plot_signal=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Example showing a waveform being created, transferred to the instrument,
and applied to a channel</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def example_set_and_use_custom_waveform(fgen=None, address=None, channel=1,
                                        plot_signal=True):
    &#34;&#34;&#34;Example showing a waveform being created, transferred to the instrument,
    and applied to a channel&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_set_and_use_custom_waveform.__doc__)
    # Create a signal
    x = np.linspace(0, 4*np.pi, 8000)
    signal = np.sin(x)+x/5
    if plot_signal: # plot the signal for visual control
        import matplotlib.pyplot as plt
        plt.plot(signal)
        plt.show()
    # Create initialise fgen if it was not supplied
    if fgen is None:
        fgen = FuncGen(address)
        close_fgen = True # specify that it should be closed at end of function
    else:
        close_fgen = False # do not close the supplied fgen at end
    print(&#34;Current waveform catalogue&#34;)
    for i, wav in enumerate(fgen.get_waveform_catalogue()):
        print(&#34;  {}: {}&#34;.format(i, wav))
    # Transfer the waveform
    fgen.set_custom_waveform(signal, memory_num=5, verify=True)
    print(&#34;New waveform catalogue:&#34;)
    for i, wav in enumerate(fgen.get_waveform_catalogue()):
        print(&#34;  {}: {}&#34;.format(i, wav))
    print(&#34;Set new wavefrom to channel {}..&#34;.format(channel), end=&#34; &#34;)
    fgen.channels[channel-1].set_output_state(&#34;OFF&#34;)
    fgen.channels[channel-1].set_function(&#34;USER5&#34;)
    print(&#34;ok&#34;)
    # Print current settings
    fgen.get_settings()
    if close_fgen: fgen.close()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tektronix_func_gen.FuncGen"><code class="flex name class">
<span>class <span class="ident">FuncGen</span></span>
<span>(</span><span>address, impedance=('highZ', 'highZ'), timeout=5000, verify_param_set=False, override_compatibility=False, verbose=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Class for interacting with Tektronix function generator</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>VISA address of insrument</dd>
<dt><strong><code>impedance</code></strong> :&ensp;<code>tuple</code> of {<code>"highZ"</code>, <code>"50ohm"</code>}, default (<code>"highZ"</code>,)*<code>2</code></dt>
<dd>Determines voltage limits associated with high impedance (whether the
instrument is using 50ohm or high Z cannot be controlled through VISA).
For example <code>("highZ", "50ohm")</code> for to use high Z for ch1 and
50 ohm for ch2</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code>, default <code>5000</code></dt>
<dd>Timeout in milliseconds of instrument connection</dd>
<dt><strong><code>verify_param_set</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Verify that a value is successfully set after executing a set function</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Choose whether to print information such as model upon connecting etc</dd>
<dt><strong><code>override_compatibility</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If the instrument limits for the model connected to are not known
<a title="tektronix_func_gen.NotCompatibleError" href="#tektronix_func_gen.NotCompatibleError"><code>NotCompatibleError</code></a> will be raised. To override and use AFG1022 limits,
set to <code>True</code>. Note that this might lead to unexpected behaviour for
custom waveforms and 'MIN'/'MAX' keywords.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>The VISA address of the instrument</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>Comma separated string with maker, model, serial and firmware of
the instrument</dd>
<dt><strong><code>inst</code></strong> :&ensp;<code>pyvisa.resources.Resource</code></dt>
<dd>The PyVISA resource</dd>
<dt><strong><code>channels</code></strong> :&ensp;<code>tuple</code> of <a title="tektronix_func_gen.FuncGenChannel" href="#tektronix_func_gen.FuncGenChannel"><code>FuncGenChannel</code></a></dt>
<dd>Objects to control the channels</dd>
<dt><strong><code>ch1</code></strong> :&ensp;<a title="tektronix_func_gen.FuncGenChannel" href="#tektronix_func_gen.FuncGenChannel"><code>FuncGenChannel</code></a></dt>
<dd>Short hand for <code>channels[0]</code> Object to control channel 1</dd>
<dt><strong><code>ch2</code></strong> :&ensp;<a title="tektronix_func_gen.FuncGenChannel" href="#tektronix_func_gen.FuncGenChannel"><code>FuncGenChannel</code></a></dt>
<dd>Short hand for <code>channels[1]</code> Object to control channel 2</dd>
<dt><strong><code>instrument_limits</code></strong> :&ensp;<code>dict</code></dt>
<dd>Contains the following keys with subdictionaries
<code>frequency lims</code>
Containing the frequency limits for the instrument where the keys
"min" and "max" have values corresponding to minimum and maximum
frequencies in Hz
<code>voltage lims</code>
Contains the maximum absolute voltage the instrument can output
for the keys "50ohm" and "highZ" according to the impedance setting
<code>amplitude lims</code>
Contains the smallest and largest possible amplitudes where the
keys "50ohm" and "highZ" will have subdictionaries with keys
"min" and "max"</dd>
<dt><strong><code>arbitrary_waveform_length</code></strong> :&ensp;<code>list</code></dt>
<dd>The permitted minimum and maximum length of an arbitrary waveform,
e.g. [2, 8192]</dd>
<dt><strong><code>arbitrary_waveform_resolution</code></strong> :&ensp;<code>int</code></dt>
<dd>The vertical resolution of the arbitrary waveform, for instance 14 bit
=&gt; 2**14-1 = 16383</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>pyvisa.Error</code></dt>
<dd>If the supplied VISA address cannot be connected to</dd>
<dt><a title="tektronix_func_gen.NotCompatibleError" href="#tektronix_func_gen.NotCompatibleError"><code>NotCompatibleError</code></a></dt>
<dd>If the instrument limits for the model connected to are not known
(Call the class with <code>override_compatibility=True</code> to override and
use AFG1022 limits)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FuncGen():
    &#34;&#34;&#34;Class for interacting with Tektronix function generator

    Parameters
    ----------
    address : str
        VISA address of insrument
    impedance : tuple of {&#34;highZ&#34;, &#34;50ohm&#34;}, default (&#34;highZ&#34;,)*2
        Determines voltage limits associated with high impedance (whether the
        instrument is using 50ohm or high Z cannot be controlled through VISA).
        For example `(&#34;highZ&#34;, &#34;50ohm&#34;)` for to use high Z for ch1 and
        50 ohm for ch2
    timeout : int, default 5000
        Timeout in milliseconds of instrument connection
    verify_param_set : bool, default False
        Verify that a value is successfully set after executing a set function
    verbose : bool, default `True`
        Choose whether to print information such as model upon connecting etc
    override_compatibility : bool, default `False`
        If the instrument limits for the model connected to are not known
        `NotCompatibleError` will be raised. To override and use AFG1022 limits,
        set to `True`. Note that this might lead to unexpected behaviour for
        custom waveforms and &#39;MIN&#39;/&#39;MAX&#39; keywords.

    Attributes
    ----------
    address : str
        The VISA address of the instrument
    id : str
        Comma separated string with maker, model, serial and firmware of
        the instrument
    inst : `pyvisa.resources.Resource`
        The PyVISA resource
    channels : tuple of FuncGenChannel
        Objects to control the channels
    ch1 : FuncGenChannel
        Short hand for `channels[0]` Object to control channel 1
    ch2 : FuncGenChannel
        Short hand for `channels[1]` Object to control channel 2
    instrument_limits : dict
        Contains the following keys with subdictionaries
        `frequency lims`
            Containing the frequency limits for the instrument where the keys
            &#34;min&#34; and &#34;max&#34; have values corresponding to minimum and maximum
            frequencies in Hz
        `voltage lims`
            Contains the maximum absolute voltage the instrument can output
            for the keys &#34;50ohm&#34; and &#34;highZ&#34; according to the impedance setting
        `amplitude lims`
            Contains the smallest and largest possible amplitudes where the
            keys &#34;50ohm&#34; and &#34;highZ&#34; will have subdictionaries with keys
            &#34;min&#34; and &#34;max&#34;
    arbitrary_waveform_length : list
        The permitted minimum and maximum length of an arbitrary waveform,
        e.g. [2, 8192]
    arbitrary_waveform_resolution : int
        The vertical resolution of the arbitrary waveform, for instance 14 bit
        =&gt; 2**14-1 = 16383

    Raises
    ------
    pyvisa.Error
        If the supplied VISA address cannot be connected to
    NotCompatibleError
        If the instrument limits for the model connected to are not known
        (Call the class with `override_compatibility=True` to override and
        use AFG1022 limits)
    &#34;&#34;&#34;

    def __init__(self, address, impedance=(&#34;highZ&#34;,)*2, timeout=5000,
                 verify_param_set=False, override_compatibility=False,
                 verbose=True):
        self.override_compatibility = override_compatibility
        self.address = address
        self.timeout = timeout
        self.verify_param_set = verify_param_set
        self.verbose = verbose
        try:
            rm = pyvisa.ResourceManager()
            self.inst = rm.open_resource(address)
        except pyvisa.Error:
            print(&#34;\nVisaError: Could not connect to \&#39;{}\&#39;&#34;.format(address))
            raise
        self.inst.timeout = self.timeout
        # Clear all the event registers and queues used in the instrument
        # status and event reporting system
        self.write(&#34;*CLS&#34;)
        # Get information about the connected device
        self.id = self.query(&#34;*IDN?&#34;)
        # Second query might be needed due to unknown reason
        # (suspecting *CLS does something weird)
        if self.id == &#39;&#39;:
            self.id = self.query(&#34;*IDN?&#34;)
        self.maker, self.model, self.serial = self.id.split(&#34;,&#34;)[:3]
        if self.verbose:
            print(&#34;Connected to {} model {}, serial&#34;
                  &#34; {}&#34;.format(self.maker, self.model, self.serial))
        self.initialise_model_properties()
        self.channels = (self.spawn_channel(1, impedance[0]),
                         self.spawn_channel(2, impedance[1]))
        self.ch1, self.ch2 = self.channels

    def __enter__(self, **kwargs):
        # The kwargs will be passed on to __init__
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def __del__(self):
        self.close()

    def close(self):
        &#34;&#34;&#34;Close the connection to the instrument&#34;&#34;&#34;
        self.inst.close()

    def initialise_model_properties(self):
        &#34;&#34;&#34;Initialises the limits of what the instrument can handle according
        to the instrument model

        Raises
        ------
        NotCompatibleError
            If the connected model is not necessarily compatible with this
            package, slimits are not known.
        &#34;&#34;&#34;
        if self.model == &#39;AFG1022&#39; or self.override_compatibility:
            self.instrument_limits = {
                &#34;frequency lims&#34;: ({&#34;min&#34;: 1e-6, &#34;max&#34;: 25e6}, &#34;Hz&#34;),
                &#34;voltage lims&#34;:   ({&#34;50ohm&#34;: {&#34;min&#34;: -5, &#34;max&#34;: 5},
                                    &#34;highZ&#34;: {&#34;min&#34;: -10, &#34;max&#34;: 10}}, &#34;V&#34;),
                &#34;amplitude lims&#34;: ({&#34;50ohm&#34;: {&#34;min&#34;: 0.001, &#34;max&#34;: 10},
                                    &#34;highZ&#34;: {&#34;min&#34;: 0.002, &#34;max&#34;: 20}}, &#34;Vpp&#34;)}
            self.arbitrary_waveform_length = [2, 8192]  # min length, max length
            self.arbitrary_waveform_resolution = 16383  # 14 bit
        else:
            msg = (&#34;Model {} not supported, no limits set!&#34;
                   &#34;\n\tTo use the limits for AFG1022, call the class with &#34;
                   &#34;&#39;override_compatibility=True&#39;&#34;
                   &#34;\n\tNote that this might lead to unexpected behaviour &#34;
                   &#34;for custom waveforms and &#39;MIN&#39;/&#39;MAX&#39; keywords.&#34;)
            raise NotCompatibleError(msg)

    def write(self, command, custom_err_message=None):
        &#34;&#34;&#34;Write a VISA command to the instrument

        Parameters
        ----------
        command : str
            The VISA command to be written to the instrument
        custom_err_message : str, default `None`
            When `None`, the RuntimeError message is &#34;Writing/querying command
            {command} failed: pyvisa returned StatusCode ..&#34;.
            Otherwise, if a message is supplied &#34;Could not {message}:
            pyvisa returned StatusCode ..&#34;

        Returns
        -------
        bytes : int
            Number of bytes tranferred

        Raises
        ------
        RuntimeError
            If status returned by PyVISA write command is not
            `pyvisa.constants.StatusCode.success`
        &#34;&#34;&#34;
        num_bytes = self.inst.write(command)
        self.check_pyvisa_status(command, custom_err_message=custom_err_message)
        return num_bytes

    def query(self, command, custom_err_message=None):
        &#34;&#34;&#34;Query the instrument

        Parameters
        ----------
        command : str
            The VISA query command
        custom_err_message : str, default `None`
            When `None`, the RuntimeError message is &#34;Writing/querying command
            {command} failed: pyvisa returned StatusCode ..&#34;.
            Otherwise, if a message is supplied &#34;Could not {message}:
            pyvisa returned StatusCode ..&#34;

        Returns
        -------
        str
            The instrument&#39;s response

        Raises
        ------
        RuntimeError
            If status returned by PyVISA write command is not
            `pyvisa.constants.StatusCode.success`
        &#34;&#34;&#34;
        response = self.inst.query(command).strip()
        self.check_pyvisa_status(command, custom_err_message=custom_err_message)
        return response

    def check_pyvisa_status(self, command, custom_err_message=None):
        &#34;&#34;&#34;Check the last status code of PyVISA

        Parameters
        ----------
        command : str
            The VISA write/query command

        Returns
        -------
        status : pyvisa.constants.StatusCode
            Return value of the library call

        Raises
        ------
        RuntimeError
            If status returned by PyVISA write command is not
            `pyvisa.constants.StatusCode.success`
        &#34;&#34;&#34;
        status = self.inst.last_status
        if not status == pyvisa.constants.StatusCode.success:
            if custom_err_message is not None:
                msg = (&#34;Could not {}: pyvisa returned StatusCode {} &#34;
                       &#34;({})&#34;.format(custom_err_message, status, str(status)))
                raise RuntimeError(msg)
            else:
                msg = (&#34;Writing/querying command {} failed: pyvisa returned StatusCode&#34;
                       &#34; {} ({})&#34;.format(command, status, str(status)))
                raise RuntimeError(msg)
        return status

    def get_error(self):
        &#34;&#34;&#34;Get the contents of the Error/Event queue on the device

        Returns
        -------
        str
            Error/event number, description of error/event
        &#34;&#34;&#34;
        return self.query(&#34;SYSTEM:ERROR:NEXT?&#34;)

    def spawn_channel(self, channel, impedance):
        &#34;&#34;&#34;Wrapper function to create a `FuncGenChannel` object for
        a channel -- see the class docstring&#34;&#34;&#34;
        return FuncGenChannel(self, channel, impedance)

    def get_settings(self):
        &#34;&#34;&#34;Get dictionaries of the current settings of the two channels

        Returns
        -------
        settings : list of dicts
            [ch1_dict, ch2_dict]: Settings currently in use as a dictionary
            with keys output, function, amplitude, offset, and frequency with
            corresponding values
        &#34;&#34;&#34;
        return [ch.get_settings() for ch in self.channels]

    def print_settings(self):
        &#34;&#34;&#34;Prints table of the current setting for both channels&#34;&#34;&#34;
        settings = self.get_settings()
        # Find the necessary padding for the table columns
        # by evaluating the maximum length of the entries
        key_padding = max([len(key) for key in settings[0].keys()])
        ch_paddings = [max([len(str(val[0])) for val in ch_settings.values()])
                       for ch_settings in settings]
        padding = [key_padding]+ch_paddings
        print(&#34;\nCurrent settings for {} {} {}\n&#34;.format(self.maker,
                                                         self.model,
                                                         self.serial))
        row_format = &#34;{:&gt;{padd[0]}s} {:{padd[1]}s} {:{padd[2]}s} {}&#34;
        table_header = row_format.format(&#34;Setting&#34;, &#34;Ch1&#34;, &#34;Ch2&#34;,
                                         &#34;Unit&#34;, padd=padding)
        print(table_header)
        print(&#34;=&#34;*len(table_header))
        for (ch1key, (ch1val, unit)), (_, (ch2val, _)) in zip(settings[0].items(),
                                                              settings[1].items()):
            print(row_format.format(ch1key, str(ch1val), str(ch2val),
                                    unit, padd=padding))

    def set_settings(self, settings):
        &#34;&#34;&#34;Set the settings of both channels with settings dictionaries

        (Each channel is turned off before applying the changes to avoid
        potenitally harmful combinations)

        Parameteres
        -----------
        settings : list of dicts
            List of settings dictionaries as returned by `get_settings`, first
            entry for channel 1, second for channel 2. The dictionaries should
            have keys output, function, amplitude, offset, and frequency
        &#34;&#34;&#34;
        for ch, s in zip(self.channels, settings):
            ch.set_settings(s)

    def syncronise_waveforms(self):
        &#34;&#34;&#34;Syncronise waveforms of the two channels when using the same frequency

        Note: Does NOT enable the frequency lock that can be enabled on the
        user interface of the instrument)
        &#34;&#34;&#34;
        self.write(&#34;:PHAS:INIT&#34;, custom_err_message=&#34;syncronise waveforms&#34;)

    def get_frequency_lock(self):
        &#34;&#34;&#34;Check if frequency lock is enabled

        Returns
        -------
        bool
            `True` if frequency lock enabled
        &#34;&#34;&#34;
        # If one is locked so is the other, so just need to check one
        return int(self.query(&#34;SOURCE1:FREQuency:CONCurrent?&#34;)) == 1

    def set_frequency_lock(self, state, use_channel=1):
        &#34;&#34;&#34;Enable the frequency lock to make the two channels have the same
        frequency and phase of their signals, also after adjustments.

        See also `FuncGen.syncronise_waveforms` for one-time sync only.

        Parameters
        ----------
        state : {&#34;ON&#34;, &#34;OFF&#34;}
            ON to enable, OFF to disable the lock
        use_channel : int, default 1
            Only relevant if turning the lock ON: The channel whose frequency
            shall be used as the common freqency
        &#34;&#34;&#34;
        if self.verbose:
            if state.lower() == &#34;off&#34; and not self.get_frequency_lock():
                print(&#34;(!) {}: Tried to disable frequency lock, but &#34;
                      &#34;frequency lock was not enabled&#34;.format(self.model))
                return
            if state.lower() == &#34;on&#34; and self.get_frequency_lock():
                print(&#34;(!) {}: Tried to enable frequency lock, but &#34;
                      &#34;frequency lock was already enabled&#34;.format(self.model))
                return
        # (Sufficient to disable for only one of the channels)
        cmd = &#34;SOURCE{}:FREQuency:CONCurrent {}&#34;.format(use_channel, state)
        msg = &#34;turn frequency lock {}&#34;.format(state)
        self.write(cmd, custom_err_message=msg)

    def software_trig(self):
        &#34;&#34;&#34;NOT TESTED: sends a trigger signal to the device
        (for bursts or modulations)&#34;&#34;&#34;
        self.write(&#34;*TRG&#34;, custom_err_message=&#34;send trigger signal&#34;)


    ## ~~~~~~~~~~~~~~~~~~~~~ CUSTOM WAVEFORM FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~ ##

    def get_waveform_catalogue(self):
        &#34;&#34;&#34;Get list of the waveforms that are in use (not empty)

        Returns
        -------
        catalogue : list
            Strings with the names of the user functions that are not empty
        &#34;&#34;&#34;
        catalogue = self.query(&#34;DATA:CATalog?&#34;).split(&#34;,&#34;)
        catalogue = [wf[1:-1] for wf in catalogue] # strip off extra quotes
        return catalogue

    def get_custom_waveform(self, memory_num):
        &#34;&#34;&#34;Get the waveform currently stored in USER&lt;memory_num&gt;

        Parameters
        ----------
        memory_num : str or int {0,...,255}, default 0
            Select which user memory to compare with

        Returns
        -------
        waveform : ndarray
            Waveform as ints spanning the resolution of the function gen or
            and empty array if waveform not in use
        &#34;&#34;&#34;
        # Find the wavefroms in use
        waveforms_in_use = self.get_waveform_catalogue()
        if &#34;USER{}&#34;.format(memory_num) in waveforms_in_use:
            # Copy the waveform to edit memory
            self.write(&#34;DATA:COPY EMEMory,USER{}&#34;.format(memory_num))
            # Get the length of the waveform
            waveform_length = int(self.query(&#34;DATA:POINts? EMEMory&#34;))
            # Get the waveform (returns binary values)
            waveform = self.inst.query_binary_values(&#34;DATA:DATA? EMEMory&#34;,
                                                     datatype=&#39;H&#39;,
                                                     is_big_endian=True,
                                                     container=np.ndarray)
            msg = (&#34;Waveform length from native length command (DATA:POINts?) &#34;
                   &#34;and the processed binary values do not match, {} and {} &#34;
                   &#34;respectively&#34;.format(waveform_length, len(waveform)))
            assert len(waveform) == waveform_length, msg
            return waveform
        else:
            print(&#34;Waveform USER{} is not in use&#34;.format(memory_num))
            return np.array([])

    def set_custom_waveform(self, waveform, normalise=True, memory_num=0,
                            verify=True, print_progress=True):
        &#34;&#34;&#34;Transfer waveform data to edit memory and then user memory.
        NOTE: Will overwrite without warnings

        Parameters
        ----------
        waveform : ndarray
            Either unnormalised arbitrary waveform (then use `normalise=True`),
            or ints spanning the resolution of the function generator
        normalise : bool
            Choose whether to normalise the waveform to ints over the
            resolution span of the function generator
        memory_num : str or int {0,...,255}, default 0
            Select which user memory to copy to
        verify : bool, default `True`
            Verify that the waveform has been transferred and is what was sent
        print_progress : bool, default `True`

        Returns
        -------
        waveform : ndarray
            The normalised waveform transferred

        Raises
        ------
        ValueError
            If the waveform is not within the permitted length or value range
        RuntimeError
            If the waveform transferred to the instrument is of a different
            length than the waveform supplied
        &#34;&#34;&#34;
        # Check if waveform data is suitable
        if print_progress:
            print(&#34;Check if waveform data is suitable..&#34;, end=&#34; &#34;)
        self.check_arb_waveform_length(waveform)
        try:
            self.check_arb_waveform_type_and_range(waveform)
        except ValueError as e:
            if print_progress:
                print(&#34;\n  &#34;+str(e))
                print(&#34;Trying again normalising the waveform..&#34;, end=&#34; &#34;)
            waveform = self.normalise_to_waveform(waveform)
        if print_progress:
            print(&#34;ok&#34;)
            print(&#34;Transfer waveform to function generator..&#34;, end=&#34; &#34;)
        # Transfer waveform
        self.inst.write_binary_values(&#34;DATA:DATA EMEMory,&#34;, waveform,
                                      datatype=&#39;H&#39;, is_big_endian=True)
        # The first query after the write_binary_values returns &#39;&#39;,
        # so here is a mock query
        self.query(&#34;&#34;)
        transfer_error = self.get_error()
        emem_wf_length = self.query(&#34;DATA:POINts? EMEMory&#34;)
        if emem_wf_length == &#39;&#39; or not int(emem_wf_length) == len(waveform):
            msg = (&#34;Waveform in temporary EMEMory has a length of {}, not of &#34;
                   &#34;the same length as the waveform ({}).\nError from the &#34;
                   &#34;instrument: {}&#34;.format(emem_wf_length, len(waveform),
                                           transfer_error))
            raise RuntimeError(msg)
        if print_progress:
            print(&#34;ok&#34;)
            print(&#34;Copy waveform to USER{}..&#34;.format(memory_num), end=&#34; &#34;)
        self.write(&#34;DATA:COPY USER{},EMEMory&#34;.format(memory_num))
        if print_progress:
            print(&#34;ok&#34;)
        if verify:
            if print_progress:
                print(&#34;Verify waveform USER{}..&#34;.format(memory_num))
            if &#34;USER{}&#34;.format(memory_num) in self.get_waveform_catalogue():
                self.verify_waveform(waveform, memory_num, normalise=normalise,
                                     print_result=print_progress)
            else:
                print(&#34;(!) USER{} is empty&#34;.format(memory_num))
        return waveform

    def normalise_to_waveform(self, shape):
        &#34;&#34;&#34;Normalise a shape of any discretisation and range to a waveform that
        can be transmitted to the function generator

        .. note::
            If you are transferring a flat/constant waveform, do not use this
            normaisation function. Transfer a waveform like
            `int(self.arbitrary_waveform_resolution/2)*np.ones(2).astype(np.int32)`
            without normalising for a well behaved flat function.

        Parameters
        ----------
        shape : array_like
            Array to be transformed to waveform, can be ints or floats,
            any normalisation or discretisation

        Returns
        -------
        waveform : ndarray
            Waveform as ints spanning the resolution of the function gen
        &#34;&#34;&#34;
        # Check if waveform data is suitable
        self.check_arb_waveform_length(shape)
        # Normalise
        waveform = shape - np.min(shape)
        normalisation_factor = np.max(waveform)
        waveform = waveform/normalisation_factor*self.arbitrary_waveform_resolution
        return waveform.astype(np.uint16)

    def verify_waveform(self, waveform, memory_num, normalise=True,
                        print_result=True):
        &#34;&#34;&#34;Compare a waveform in user memory to argument waveform

        Parameters
        ----------
        waveform : ndarray
            Waveform as ints spanning the resolution of the function gen
        memory_num : str or int {0,...,255}, default 0
            Select which user memory to compare with
        normalise : bool, default `True`
            Normalise test waveform

        Returns
        -------
        bool
            Boolean according to equal/not equal
        instrument_waveform
            The waveform on the instrument
        list or `None`
            List of the indices where the waveforms are not equal or `None` if
            the waveforms were of different lengths
        &#34;&#34;&#34;
        if normalise: # make sure test waveform is normalised
            waveform = self.normalise_to_waveform(waveform)
        # Get the waveform on the instrument
        instrument_waveform = self.get_custom_waveform(memory_num)
        # Compare lengths
        len_inst_wav, len_wav = len(instrument_waveform), len(waveform)
        if not len_inst_wav == len_wav:
            if print_result:
                print(&#34;The waveform in USER{} and the compared waveform are &#34;
                      &#34;not of same length (instrument {} vs {})&#34;
                      &#34;&#34;.format(memory_num, len_inst_wav, len_wav))
            return False, instrument_waveform, None
        # Compare each element
        not_equal = []
        for i in range(len_wav):
            if not instrument_waveform[i] == waveform[i]:
                not_equal.append(i)
        # Return depending of whether list is empty or not
        if not not_equal: # if list is empty
            if print_result:
                print(&#34;The waveform in USER{} and the compared waveform &#34;
                      &#34;are equal&#34;.format(memory_num))
            return True, instrument_waveform, not_equal
        if print_result:
            print(&#34;The waveform in USER{} and the compared waveform are &#34;
                  &#34;NOT equal&#34;.format(memory_num))
        return False, instrument_waveform, not_equal

    def check_arb_waveform_length(self, waveform):
        &#34;&#34;&#34;Checks if waveform is within the acceptable length

        Parameters
        ----------
        waveform : array_like
            Waveform or voltage list to be checked

        Raises
        ------
        ValueError
            If the waveform is not within the permitted length
        &#34;&#34;&#34;
        if ((len(waveform) &lt; self.arbitrary_waveform_length[0]) or
            (len(waveform) &gt; self.arbitrary_waveform_length[1])):
            msg = (&#34;The waveform is of length {}, which is not within the &#34;
                   &#34;acceptable length {} &lt; len &lt; {}&#34;
                   &#34;&#34;.format(len(waveform), *self.arbitrary_waveform_length))
            raise ValueError(msg)

    def check_arb_waveform_type_and_range(self, waveform):
        &#34;&#34;&#34;Checks if waveform is of int/np.int32 type and within the resolution
        of the function generator

        Parameters
        ----------
        waveform : array_like
            Waveform or voltage list to be checked

        Raises
        ------
        ValueError
            If the waveform values are not int, np.uint16 or np.int32, or the
            values are not within the permitted range
        &#34;&#34;&#34;
        for value in waveform:
            if not isinstance(value, (int, np.uint16, np.int32)):
                raise ValueError(&#34;The waveform contains values that are not&#34;
                                 &#34;int, np.uint16 or np.int32&#34;)
            if (value &lt; 0) or (value &gt; self.arbitrary_waveform_resolution):
                raise ValueError(&#34;The waveform contains values out of range &#34;
                                 &#34;({} is not within the resolution &#34;
                                 &#34;[0, {}])&#34;.format(value,
                                        self.arbitrary_waveform_resolution))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tektronix_func_gen.FuncGen.check_arb_waveform_length"><code class="name flex">
<span>def <span class="ident">check_arb_waveform_length</span></span>(<span>self, waveform)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks if waveform is within the acceptable length</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>waveform</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Waveform or voltage list to be checked</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the waveform is not within the permitted length</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_arb_waveform_length(self, waveform):
    &#34;&#34;&#34;Checks if waveform is within the acceptable length

    Parameters
    ----------
    waveform : array_like
        Waveform or voltage list to be checked

    Raises
    ------
    ValueError
        If the waveform is not within the permitted length
    &#34;&#34;&#34;
    if ((len(waveform) &lt; self.arbitrary_waveform_length[0]) or
        (len(waveform) &gt; self.arbitrary_waveform_length[1])):
        msg = (&#34;The waveform is of length {}, which is not within the &#34;
               &#34;acceptable length {} &lt; len &lt; {}&#34;
               &#34;&#34;.format(len(waveform), *self.arbitrary_waveform_length))
        raise ValueError(msg)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.check_arb_waveform_type_and_range"><code class="name flex">
<span>def <span class="ident">check_arb_waveform_type_and_range</span></span>(<span>self, waveform)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks if waveform is of int/np.int32 type and within the resolution
of the function generator</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>waveform</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Waveform or voltage list to be checked</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the waveform values are not int, np.uint16 or np.int32, or the
values are not within the permitted range</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_arb_waveform_type_and_range(self, waveform):
    &#34;&#34;&#34;Checks if waveform is of int/np.int32 type and within the resolution
    of the function generator

    Parameters
    ----------
    waveform : array_like
        Waveform or voltage list to be checked

    Raises
    ------
    ValueError
        If the waveform values are not int, np.uint16 or np.int32, or the
        values are not within the permitted range
    &#34;&#34;&#34;
    for value in waveform:
        if not isinstance(value, (int, np.uint16, np.int32)):
            raise ValueError(&#34;The waveform contains values that are not&#34;
                             &#34;int, np.uint16 or np.int32&#34;)
        if (value &lt; 0) or (value &gt; self.arbitrary_waveform_resolution):
            raise ValueError(&#34;The waveform contains values out of range &#34;
                             &#34;({} is not within the resolution &#34;
                             &#34;[0, {}])&#34;.format(value,
                                    self.arbitrary_waveform_resolution))</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.check_pyvisa_status"><code class="name flex">
<span>def <span class="ident">check_pyvisa_status</span></span>(<span>self, command, custom_err_message=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Check the last status code of PyVISA</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>str</code></dt>
<dd>The VISA write/query command</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>pyvisa.constants.StatusCode</code></dt>
<dd>Return value of the library call</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If status returned by PyVISA write command is not
<code>pyvisa.constants.StatusCode.success</code></dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_pyvisa_status(self, command, custom_err_message=None):
    &#34;&#34;&#34;Check the last status code of PyVISA

    Parameters
    ----------
    command : str
        The VISA write/query command

    Returns
    -------
    status : pyvisa.constants.StatusCode
        Return value of the library call

    Raises
    ------
    RuntimeError
        If status returned by PyVISA write command is not
        `pyvisa.constants.StatusCode.success`
    &#34;&#34;&#34;
    status = self.inst.last_status
    if not status == pyvisa.constants.StatusCode.success:
        if custom_err_message is not None:
            msg = (&#34;Could not {}: pyvisa returned StatusCode {} &#34;
                   &#34;({})&#34;.format(custom_err_message, status, str(status)))
            raise RuntimeError(msg)
        else:
            msg = (&#34;Writing/querying command {} failed: pyvisa returned StatusCode&#34;
                   &#34; {} ({})&#34;.format(command, status, str(status)))
            raise RuntimeError(msg)
    return status</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Close the connection to the instrument</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;Close the connection to the instrument&#34;&#34;&#34;
    self.inst.close()</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.get_custom_waveform"><code class="name flex">
<span>def <span class="ident">get_custom_waveform</span></span>(<span>self, memory_num)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the waveform currently stored in USER<memory_num></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>memory_num</code></strong> :&ensp;<code>str</code> or <code>int</code> {<code>0</code>,<code>...</code>,<code>255</code>}, default <code>0</code></dt>
<dd>Select which user memory to compare with</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>waveform</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Waveform as ints spanning the resolution of the function gen or
and empty array if waveform not in use</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_custom_waveform(self, memory_num):
    &#34;&#34;&#34;Get the waveform currently stored in USER&lt;memory_num&gt;

    Parameters
    ----------
    memory_num : str or int {0,...,255}, default 0
        Select which user memory to compare with

    Returns
    -------
    waveform : ndarray
        Waveform as ints spanning the resolution of the function gen or
        and empty array if waveform not in use
    &#34;&#34;&#34;
    # Find the wavefroms in use
    waveforms_in_use = self.get_waveform_catalogue()
    if &#34;USER{}&#34;.format(memory_num) in waveforms_in_use:
        # Copy the waveform to edit memory
        self.write(&#34;DATA:COPY EMEMory,USER{}&#34;.format(memory_num))
        # Get the length of the waveform
        waveform_length = int(self.query(&#34;DATA:POINts? EMEMory&#34;))
        # Get the waveform (returns binary values)
        waveform = self.inst.query_binary_values(&#34;DATA:DATA? EMEMory&#34;,
                                                 datatype=&#39;H&#39;,
                                                 is_big_endian=True,
                                                 container=np.ndarray)
        msg = (&#34;Waveform length from native length command (DATA:POINts?) &#34;
               &#34;and the processed binary values do not match, {} and {} &#34;
               &#34;respectively&#34;.format(waveform_length, len(waveform)))
        assert len(waveform) == waveform_length, msg
        return waveform
    else:
        print(&#34;Waveform USER{} is not in use&#34;.format(memory_num))
        return np.array([])</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.get_error"><code class="name flex">
<span>def <span class="ident">get_error</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the contents of the Error/Event queue on the device</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Error/event number, description of error/event</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_error(self):
    &#34;&#34;&#34;Get the contents of the Error/Event queue on the device

    Returns
    -------
    str
        Error/event number, description of error/event
    &#34;&#34;&#34;
    return self.query(&#34;SYSTEM:ERROR:NEXT?&#34;)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.get_frequency_lock"><code class="name flex">
<span>def <span class="ident">get_frequency_lock</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if frequency lock is enabled</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if frequency lock enabled</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frequency_lock(self):
    &#34;&#34;&#34;Check if frequency lock is enabled

    Returns
    -------
    bool
        `True` if frequency lock enabled
    &#34;&#34;&#34;
    # If one is locked so is the other, so just need to check one
    return int(self.query(&#34;SOURCE1:FREQuency:CONCurrent?&#34;)) == 1</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.get_settings"><code class="name flex">
<span>def <span class="ident">get_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get dictionaries of the current settings of the two channels</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>settings</code></strong> :&ensp;<code>list</code> of <code>dicts</code></dt>
<dd>[ch1_dict, ch2_dict]: Settings currently in use as a dictionary
with keys output, function, amplitude, offset, and frequency with
corresponding values</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_settings(self):
    &#34;&#34;&#34;Get dictionaries of the current settings of the two channels

    Returns
    -------
    settings : list of dicts
        [ch1_dict, ch2_dict]: Settings currently in use as a dictionary
        with keys output, function, amplitude, offset, and frequency with
        corresponding values
    &#34;&#34;&#34;
    return [ch.get_settings() for ch in self.channels]</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.get_waveform_catalogue"><code class="name flex">
<span>def <span class="ident">get_waveform_catalogue</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get list of the waveforms that are in use (not empty)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>catalogue</code></strong> :&ensp;<code>list</code></dt>
<dd>Strings with the names of the user functions that are not empty</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_waveform_catalogue(self):
    &#34;&#34;&#34;Get list of the waveforms that are in use (not empty)

    Returns
    -------
    catalogue : list
        Strings with the names of the user functions that are not empty
    &#34;&#34;&#34;
    catalogue = self.query(&#34;DATA:CATalog?&#34;).split(&#34;,&#34;)
    catalogue = [wf[1:-1] for wf in catalogue] # strip off extra quotes
    return catalogue</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.initialise_model_properties"><code class="name flex">
<span>def <span class="ident">initialise_model_properties</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Initialises the limits of what the instrument can handle according
to the instrument model</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><a title="tektronix_func_gen.NotCompatibleError" href="#tektronix_func_gen.NotCompatibleError"><code>NotCompatibleError</code></a></dt>
<dd>If the connected model is not necessarily compatible with this
package, slimits are not known.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialise_model_properties(self):
    &#34;&#34;&#34;Initialises the limits of what the instrument can handle according
    to the instrument model

    Raises
    ------
    NotCompatibleError
        If the connected model is not necessarily compatible with this
        package, slimits are not known.
    &#34;&#34;&#34;
    if self.model == &#39;AFG1022&#39; or self.override_compatibility:
        self.instrument_limits = {
            &#34;frequency lims&#34;: ({&#34;min&#34;: 1e-6, &#34;max&#34;: 25e6}, &#34;Hz&#34;),
            &#34;voltage lims&#34;:   ({&#34;50ohm&#34;: {&#34;min&#34;: -5, &#34;max&#34;: 5},
                                &#34;highZ&#34;: {&#34;min&#34;: -10, &#34;max&#34;: 10}}, &#34;V&#34;),
            &#34;amplitude lims&#34;: ({&#34;50ohm&#34;: {&#34;min&#34;: 0.001, &#34;max&#34;: 10},
                                &#34;highZ&#34;: {&#34;min&#34;: 0.002, &#34;max&#34;: 20}}, &#34;Vpp&#34;)}
        self.arbitrary_waveform_length = [2, 8192]  # min length, max length
        self.arbitrary_waveform_resolution = 16383  # 14 bit
    else:
        msg = (&#34;Model {} not supported, no limits set!&#34;
               &#34;\n\tTo use the limits for AFG1022, call the class with &#34;
               &#34;&#39;override_compatibility=True&#39;&#34;
               &#34;\n\tNote that this might lead to unexpected behaviour &#34;
               &#34;for custom waveforms and &#39;MIN&#39;/&#39;MAX&#39; keywords.&#34;)
        raise NotCompatibleError(msg)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.normalise_to_waveform"><code class="name flex">
<span>def <span class="ident">normalise_to_waveform</span></span>(<span>self, shape)</span>
</code></dt>
<dd>
<section class="desc"><p>Normalise a shape of any discretisation and range to a waveform that
can be transmitted to the function generator</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you are transferring a flat/constant waveform, do not use this
normaisation function. Transfer a waveform like
<code>int(self.arbitrary_waveform_resolution/2)*np.ones(2).astype(np.int32)</code>
without normalising for a well behaved flat function.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Array to be transformed to waveform, can be ints or floats,
any normalisation or discretisation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>waveform</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Waveform as ints spanning the resolution of the function gen</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalise_to_waveform(self, shape):
    &#34;&#34;&#34;Normalise a shape of any discretisation and range to a waveform that
    can be transmitted to the function generator

    .. note::
        If you are transferring a flat/constant waveform, do not use this
        normaisation function. Transfer a waveform like
        `int(self.arbitrary_waveform_resolution/2)*np.ones(2).astype(np.int32)`
        without normalising for a well behaved flat function.

    Parameters
    ----------
    shape : array_like
        Array to be transformed to waveform, can be ints or floats,
        any normalisation or discretisation

    Returns
    -------
    waveform : ndarray
        Waveform as ints spanning the resolution of the function gen
    &#34;&#34;&#34;
    # Check if waveform data is suitable
    self.check_arb_waveform_length(shape)
    # Normalise
    waveform = shape - np.min(shape)
    normalisation_factor = np.max(waveform)
    waveform = waveform/normalisation_factor*self.arbitrary_waveform_resolution
    return waveform.astype(np.uint16)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.print_settings"><code class="name flex">
<span>def <span class="ident">print_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Prints table of the current setting for both channels</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_settings(self):
    &#34;&#34;&#34;Prints table of the current setting for both channels&#34;&#34;&#34;
    settings = self.get_settings()
    # Find the necessary padding for the table columns
    # by evaluating the maximum length of the entries
    key_padding = max([len(key) for key in settings[0].keys()])
    ch_paddings = [max([len(str(val[0])) for val in ch_settings.values()])
                   for ch_settings in settings]
    padding = [key_padding]+ch_paddings
    print(&#34;\nCurrent settings for {} {} {}\n&#34;.format(self.maker,
                                                     self.model,
                                                     self.serial))
    row_format = &#34;{:&gt;{padd[0]}s} {:{padd[1]}s} {:{padd[2]}s} {}&#34;
    table_header = row_format.format(&#34;Setting&#34;, &#34;Ch1&#34;, &#34;Ch2&#34;,
                                     &#34;Unit&#34;, padd=padding)
    print(table_header)
    print(&#34;=&#34;*len(table_header))
    for (ch1key, (ch1val, unit)), (_, (ch2val, _)) in zip(settings[0].items(),
                                                          settings[1].items()):
        print(row_format.format(ch1key, str(ch1val), str(ch2val),
                                unit, padd=padding))</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.query"><code class="name flex">
<span>def <span class="ident">query</span></span>(<span>self, command, custom_err_message=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Query the instrument</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>str</code></dt>
<dd>The VISA query command</dd>
<dt><strong><code>custom_err_message</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>When <code>None</code>, the RuntimeError message is "Writing/querying command
{command} failed: pyvisa returned StatusCode ..".
Otherwise, if a message is supplied "Could not {message}:
pyvisa returned StatusCode .."</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The instrument's response</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If status returned by PyVISA write command is not
<code>pyvisa.constants.StatusCode.success</code></dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query(self, command, custom_err_message=None):
    &#34;&#34;&#34;Query the instrument

    Parameters
    ----------
    command : str
        The VISA query command
    custom_err_message : str, default `None`
        When `None`, the RuntimeError message is &#34;Writing/querying command
        {command} failed: pyvisa returned StatusCode ..&#34;.
        Otherwise, if a message is supplied &#34;Could not {message}:
        pyvisa returned StatusCode ..&#34;

    Returns
    -------
    str
        The instrument&#39;s response

    Raises
    ------
    RuntimeError
        If status returned by PyVISA write command is not
        `pyvisa.constants.StatusCode.success`
    &#34;&#34;&#34;
    response = self.inst.query(command).strip()
    self.check_pyvisa_status(command, custom_err_message=custom_err_message)
    return response</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.set_custom_waveform"><code class="name flex">
<span>def <span class="ident">set_custom_waveform</span></span>(<span>self, waveform, normalise=True, memory_num=0, verify=True, print_progress=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Transfer waveform data to edit memory and then user memory.
NOTE: Will overwrite without warnings</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>waveform</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Either unnormalised arbitrary waveform (then use <code>normalise=True</code>),
or ints spanning the resolution of the function generator</dd>
<dt><strong><code>normalise</code></strong> :&ensp;<code>bool</code></dt>
<dd>Choose whether to normalise the waveform to ints over the
resolution span of the function generator</dd>
<dt><strong><code>memory_num</code></strong> :&ensp;<code>str</code> or <code>int</code> {<code>0</code>,<code>...</code>,<code>255</code>}, default <code>0</code></dt>
<dd>Select which user memory to copy to</dd>
<dt><strong><code>verify</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Verify that the waveform has been transferred and is what was sent</dd>
<dt><strong><code>print_progress</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>waveform</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The normalised waveform transferred</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the waveform is not within the permitted length or value range</dd>
<dt><code>RuntimeError</code></dt>
<dd>If the waveform transferred to the instrument is of a different
length than the waveform supplied</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_custom_waveform(self, waveform, normalise=True, memory_num=0,
                        verify=True, print_progress=True):
    &#34;&#34;&#34;Transfer waveform data to edit memory and then user memory.
    NOTE: Will overwrite without warnings

    Parameters
    ----------
    waveform : ndarray
        Either unnormalised arbitrary waveform (then use `normalise=True`),
        or ints spanning the resolution of the function generator
    normalise : bool
        Choose whether to normalise the waveform to ints over the
        resolution span of the function generator
    memory_num : str or int {0,...,255}, default 0
        Select which user memory to copy to
    verify : bool, default `True`
        Verify that the waveform has been transferred and is what was sent
    print_progress : bool, default `True`

    Returns
    -------
    waveform : ndarray
        The normalised waveform transferred

    Raises
    ------
    ValueError
        If the waveform is not within the permitted length or value range
    RuntimeError
        If the waveform transferred to the instrument is of a different
        length than the waveform supplied
    &#34;&#34;&#34;
    # Check if waveform data is suitable
    if print_progress:
        print(&#34;Check if waveform data is suitable..&#34;, end=&#34; &#34;)
    self.check_arb_waveform_length(waveform)
    try:
        self.check_arb_waveform_type_and_range(waveform)
    except ValueError as e:
        if print_progress:
            print(&#34;\n  &#34;+str(e))
            print(&#34;Trying again normalising the waveform..&#34;, end=&#34; &#34;)
        waveform = self.normalise_to_waveform(waveform)
    if print_progress:
        print(&#34;ok&#34;)
        print(&#34;Transfer waveform to function generator..&#34;, end=&#34; &#34;)
    # Transfer waveform
    self.inst.write_binary_values(&#34;DATA:DATA EMEMory,&#34;, waveform,
                                  datatype=&#39;H&#39;, is_big_endian=True)
    # The first query after the write_binary_values returns &#39;&#39;,
    # so here is a mock query
    self.query(&#34;&#34;)
    transfer_error = self.get_error()
    emem_wf_length = self.query(&#34;DATA:POINts? EMEMory&#34;)
    if emem_wf_length == &#39;&#39; or not int(emem_wf_length) == len(waveform):
        msg = (&#34;Waveform in temporary EMEMory has a length of {}, not of &#34;
               &#34;the same length as the waveform ({}).\nError from the &#34;
               &#34;instrument: {}&#34;.format(emem_wf_length, len(waveform),
                                       transfer_error))
        raise RuntimeError(msg)
    if print_progress:
        print(&#34;ok&#34;)
        print(&#34;Copy waveform to USER{}..&#34;.format(memory_num), end=&#34; &#34;)
    self.write(&#34;DATA:COPY USER{},EMEMory&#34;.format(memory_num))
    if print_progress:
        print(&#34;ok&#34;)
    if verify:
        if print_progress:
            print(&#34;Verify waveform USER{}..&#34;.format(memory_num))
        if &#34;USER{}&#34;.format(memory_num) in self.get_waveform_catalogue():
            self.verify_waveform(waveform, memory_num, normalise=normalise,
                                 print_result=print_progress)
        else:
            print(&#34;(!) USER{} is empty&#34;.format(memory_num))
    return waveform</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.set_frequency_lock"><code class="name flex">
<span>def <span class="ident">set_frequency_lock</span></span>(<span>self, state, use_channel=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Enable the frequency lock to make the two channels have the same
frequency and phase of their signals, also after adjustments.</p>
<p>See also <a title="tektronix_func_gen.FuncGen.syncronise_waveforms" href="#tektronix_func_gen.FuncGen.syncronise_waveforms"><code>FuncGen.syncronise_waveforms()</code></a> for one-time sync only.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;{<code>"ON"</code>, <code>"OFF"</code>}</dt>
<dd>ON to enable, OFF to disable the lock</dd>
<dt><strong><code>use_channel</code></strong> :&ensp;<code>int</code>, default <code>1</code></dt>
<dd>Only relevant if turning the lock ON: The channel whose frequency
shall be used as the common freqency</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_frequency_lock(self, state, use_channel=1):
    &#34;&#34;&#34;Enable the frequency lock to make the two channels have the same
    frequency and phase of their signals, also after adjustments.

    See also `FuncGen.syncronise_waveforms` for one-time sync only.

    Parameters
    ----------
    state : {&#34;ON&#34;, &#34;OFF&#34;}
        ON to enable, OFF to disable the lock
    use_channel : int, default 1
        Only relevant if turning the lock ON: The channel whose frequency
        shall be used as the common freqency
    &#34;&#34;&#34;
    if self.verbose:
        if state.lower() == &#34;off&#34; and not self.get_frequency_lock():
            print(&#34;(!) {}: Tried to disable frequency lock, but &#34;
                  &#34;frequency lock was not enabled&#34;.format(self.model))
            return
        if state.lower() == &#34;on&#34; and self.get_frequency_lock():
            print(&#34;(!) {}: Tried to enable frequency lock, but &#34;
                  &#34;frequency lock was already enabled&#34;.format(self.model))
            return
    # (Sufficient to disable for only one of the channels)
    cmd = &#34;SOURCE{}:FREQuency:CONCurrent {}&#34;.format(use_channel, state)
    msg = &#34;turn frequency lock {}&#34;.format(state)
    self.write(cmd, custom_err_message=msg)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.set_settings"><code class="name flex">
<span>def <span class="ident">set_settings</span></span>(<span>self, settings)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the settings of both channels with settings dictionaries</p>
<p>(Each channel is turned off before applying the changes to avoid
potenitally harmful combinations)</p>
<h2 id="parameteres">Parameteres</h2>
<dl>
<dt><strong><code>settings</code></strong> :&ensp;<code>list</code> of <code>dicts</code></dt>
<dd>List of settings dictionaries as returned by <code>get_settings</code>, first
entry for channel 1, second for channel 2. The dictionaries should
have keys output, function, amplitude, offset, and frequency</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_settings(self, settings):
    &#34;&#34;&#34;Set the settings of both channels with settings dictionaries

    (Each channel is turned off before applying the changes to avoid
    potenitally harmful combinations)

    Parameteres
    -----------
    settings : list of dicts
        List of settings dictionaries as returned by `get_settings`, first
        entry for channel 1, second for channel 2. The dictionaries should
        have keys output, function, amplitude, offset, and frequency
    &#34;&#34;&#34;
    for ch, s in zip(self.channels, settings):
        ch.set_settings(s)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.software_trig"><code class="name flex">
<span>def <span class="ident">software_trig</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>NOT TESTED: sends a trigger signal to the device
(for bursts or modulations)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def software_trig(self):
    &#34;&#34;&#34;NOT TESTED: sends a trigger signal to the device
    (for bursts or modulations)&#34;&#34;&#34;
    self.write(&#34;*TRG&#34;, custom_err_message=&#34;send trigger signal&#34;)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.spawn_channel"><code class="name flex">
<span>def <span class="ident">spawn_channel</span></span>(<span>self, channel, impedance)</span>
</code></dt>
<dd>
<section class="desc"><p>Wrapper function to create a <a title="tektronix_func_gen.FuncGenChannel" href="#tektronix_func_gen.FuncGenChannel"><code>FuncGenChannel</code></a> object for
a channel &ndash; see the class docstring</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spawn_channel(self, channel, impedance):
    &#34;&#34;&#34;Wrapper function to create a `FuncGenChannel` object for
    a channel -- see the class docstring&#34;&#34;&#34;
    return FuncGenChannel(self, channel, impedance)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.syncronise_waveforms"><code class="name flex">
<span>def <span class="ident">syncronise_waveforms</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Syncronise waveforms of the two channels when using the same frequency</p>
<p>Note: Does NOT enable the frequency lock that can be enabled on the
user interface of the instrument)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def syncronise_waveforms(self):
    &#34;&#34;&#34;Syncronise waveforms of the two channels when using the same frequency

    Note: Does NOT enable the frequency lock that can be enabled on the
    user interface of the instrument)
    &#34;&#34;&#34;
    self.write(&#34;:PHAS:INIT&#34;, custom_err_message=&#34;syncronise waveforms&#34;)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.verify_waveform"><code class="name flex">
<span>def <span class="ident">verify_waveform</span></span>(<span>self, waveform, memory_num, normalise=True, print_result=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Compare a waveform in user memory to argument waveform</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>waveform</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Waveform as ints spanning the resolution of the function gen</dd>
<dt><strong><code>memory_num</code></strong> :&ensp;<code>str</code> or <code>int</code> {<code>0</code>,<code>...</code>,<code>255</code>}, default <code>0</code></dt>
<dd>Select which user memory to compare with</dd>
<dt><strong><code>normalise</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Normalise test waveform</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Boolean according to equal/not equal</dd>
<dt><code>instrument_waveform</code></dt>
<dd>The waveform on the instrument</dd>
</dl>
<p>list or <code>None</code>
List of the indices where the waveforms are not equal or <code>None</code> if
the waveforms were of different lengths</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_waveform(self, waveform, memory_num, normalise=True,
                    print_result=True):
    &#34;&#34;&#34;Compare a waveform in user memory to argument waveform

    Parameters
    ----------
    waveform : ndarray
        Waveform as ints spanning the resolution of the function gen
    memory_num : str or int {0,...,255}, default 0
        Select which user memory to compare with
    normalise : bool, default `True`
        Normalise test waveform

    Returns
    -------
    bool
        Boolean according to equal/not equal
    instrument_waveform
        The waveform on the instrument
    list or `None`
        List of the indices where the waveforms are not equal or `None` if
        the waveforms were of different lengths
    &#34;&#34;&#34;
    if normalise: # make sure test waveform is normalised
        waveform = self.normalise_to_waveform(waveform)
    # Get the waveform on the instrument
    instrument_waveform = self.get_custom_waveform(memory_num)
    # Compare lengths
    len_inst_wav, len_wav = len(instrument_waveform), len(waveform)
    if not len_inst_wav == len_wav:
        if print_result:
            print(&#34;The waveform in USER{} and the compared waveform are &#34;
                  &#34;not of same length (instrument {} vs {})&#34;
                  &#34;&#34;.format(memory_num, len_inst_wav, len_wav))
        return False, instrument_waveform, None
    # Compare each element
    not_equal = []
    for i in range(len_wav):
        if not instrument_waveform[i] == waveform[i]:
            not_equal.append(i)
    # Return depending of whether list is empty or not
    if not not_equal: # if list is empty
        if print_result:
            print(&#34;The waveform in USER{} and the compared waveform &#34;
                  &#34;are equal&#34;.format(memory_num))
        return True, instrument_waveform, not_equal
    if print_result:
        print(&#34;The waveform in USER{} and the compared waveform are &#34;
              &#34;NOT equal&#34;.format(memory_num))
    return False, instrument_waveform, not_equal</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, command, custom_err_message=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Write a VISA command to the instrument</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>str</code></dt>
<dd>The VISA command to be written to the instrument</dd>
<dt><strong><code>custom_err_message</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>When <code>None</code>, the RuntimeError message is "Writing/querying command
{command} failed: pyvisa returned StatusCode ..".
Otherwise, if a message is supplied "Could not {message}:
pyvisa returned StatusCode .."</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bytes</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of bytes tranferred</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If status returned by PyVISA write command is not
<code>pyvisa.constants.StatusCode.success</code></dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, command, custom_err_message=None):
    &#34;&#34;&#34;Write a VISA command to the instrument

    Parameters
    ----------
    command : str
        The VISA command to be written to the instrument
    custom_err_message : str, default `None`
        When `None`, the RuntimeError message is &#34;Writing/querying command
        {command} failed: pyvisa returned StatusCode ..&#34;.
        Otherwise, if a message is supplied &#34;Could not {message}:
        pyvisa returned StatusCode ..&#34;

    Returns
    -------
    bytes : int
        Number of bytes tranferred

    Raises
    ------
    RuntimeError
        If status returned by PyVISA write command is not
        `pyvisa.constants.StatusCode.success`
    &#34;&#34;&#34;
    num_bytes = self.inst.write(command)
    self.check_pyvisa_status(command, custom_err_message=custom_err_message)
    return num_bytes</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel"><code class="flex name class">
<span>class <span class="ident">FuncGenChannel</span></span>
<span>(</span><span>fgen, channel, impedance)</span>
</code></dt>
<dd>
<section class="desc"><p>Class for controlling a channel on a function generator object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fgen</code></strong> :&ensp;<code>FuncGen</code></dt>
<dd>The function generator object</dd>
<dt><strong><code>channel</code></strong> :&ensp;{<code>1</code>, <code>2</code>}</dt>
<dd>The channel to be controlled</dd>
<dt><strong><code>impedance</code></strong> :&ensp;{<code>"50ohm"</code>, <code>"highZ"</code>}</dt>
<dd>Determines voltage limits associated with high impedance (whether the
instrument is using 50ohm or high Z cannot be controlled through VISA)</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>fgen</code></strong> :&ensp;<code>FuncGen</code></dt>
<dd>The function generator object for which the channel exists</dd>
<dt><strong><code>channel</code></strong> :&ensp;{<code>1</code>, <code>2</code>}</dt>
<dd>The channel number</dd>
<dt><strong><code>impedance</code></strong> :&ensp;{<code>"50ohm"</code>, <code>"highZ"</code>}</dt>
<dd>Determines voltage limits associated with high impedance (whether the
instrument is using 50ohm or high Z cannot be controlled through VISA)</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>str</code></dt>
<dd>"SOURce{}:" where {} is the channel number</dd>
<dt><strong><code>settings_units</code></strong> :&ensp;<code>list</code></dt>
<dd>The units for the settings produced by <a title="tektronix_func_gen.FuncGenChannel.get_settings" href="#tektronix_func_gen.FuncGenChannel.get_settings"><code>FuncGenChannel.get_settings()</code></a></dd>
<dt><strong><code>state_str</code></strong> :&ensp;<code>dict</code></dt>
<dd>For conversion from states 1 and 2 to "ON" and "OFF"</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FuncGenChannel:
    &#34;&#34;&#34;Class for controlling a channel on a function generator object

    Parameters
    ----------
    fgen : `FuncGen`
        The function generator object
    channel : {1, 2}
        The channel to be controlled
    impedance : {&#34;50ohm&#34;, &#34;highZ&#34;}
        Determines voltage limits associated with high impedance (whether the
        instrument is using 50ohm or high Z cannot be controlled through VISA)

    Attributes
    ----------
    fgen : `FuncGen`
        The function generator object for which the channel exists
    channel : {1, 2}
        The channel number
    impedance : {&#34;50ohm&#34;, &#34;highZ&#34;}
        Determines voltage limits associated with high impedance (whether the
        instrument is using 50ohm or high Z cannot be controlled through VISA)
    source : str
        &#34;SOURce{}:&#34; where {} is the channel number
    settings_units : list
        The units for the settings produced by `FuncGenChannel.get_settings`
    state_str : dict
        For conversion from states 1 and 2 to &#34;ON&#34; and &#34;OFF&#34;
    &#34;&#34;&#34;

    # Attributes
    state_str = {&#34;1&#34;: &#34;ON&#34;, &#34;0&#34;: &#34;OFF&#34;,
                  1 : &#34;ON&#34;,  0 : &#34;OFF&#34;}
    &#34;&#34;&#34;Dictionary for converting output states to &#34;ON&#34; and &#34;OFF&#34; &#34;&#34;&#34;

    def __init__(self, fgen, channel, impedance):
        self.fgen = fgen
        self.channel = channel
        self.source = &#34;SOURce{}:&#34;.format(channel)
        self.impedance = impedance
        # Adopt limits dictionary from instrument
        self.channel_limits = copy.deepcopy(self.fgen.instrument_limits)

    def impedance_dependent_limit(self, limit_type):
        &#34;&#34;&#34;Check if the limit type is impedance dependent (voltages) or
        not (frequency)

        Returns
        -------
        bool
            `True` if the limit is impedance dependent
        &#34;&#34;&#34;
        try: # to access the key &#34;min&#34; to check if impedance must be selected
            _ = self.channel_limits[limit_type][0][&#34;min&#34;]
            return False
        except KeyError: # if the key does not exist
            # The impedance must be selected
            return True

    def set_stricter_limits(self):
        &#34;&#34;&#34;Set limits for the voltage and frequency limits of the channel output
        through a series of prompts&#34;&#34;&#34;
        print(&#34;Set stricter voltage and frequency limits &#34;
              &#34;for channel {}&#34;.format(self.channel))
        print(&#34;Use enter only to leave a limit unchanged.&#34;)
        # Go through the different limits in the instrument_limits dict
        for limit_type, (inst_limit_dict, unit) in self.fgen.instrument_limits.items():
            use_impedance = self.impedance_dependent_limit(limit_type)
            print(&#34;Set {} in {}&#34;.format(limit_type, unit), end=&#34; &#34;)
            if use_impedance:
                inst_limit_dict = inst_limit_dict[self.impedance]
                print(&#34;[{} impedance limit]&#34;.format(self.impedance))
            else:
                print(&#34;&#34;) # get new line
            # Go through the min and max for the limit type
            for key, inst_value in inst_limit_dict.items():
                # prompt for new value
                new_value = input(&#34;  {} (instrument limit {}{}): &#34;
                                  &#34;&#34;.format(key, inst_value, unit))
                if new_value == &#34;&#34;:
                    # Do not change if empty
                    print(&#34;\tLimit not changed&#34;)
                else:
                    try: # to convert to float
                        new_value = float(new_value)
                    except ValueError:
                        print(&#34;\tLimit unchanged: Could not convert \&#39;{}\&#39; &#34;
                              &#34;to float&#34;.format(new_value))
                        continue # to next item in dict
                    # Set the new limit
                    self.set_limit(limit_type, key, new_value, verbose=True)

    def set_limit(self, limit_type, bound, new_value, verbose=False):
        &#34;&#34;&#34;Set a limit if the new value is within the instrument limits and are
        self consistent (max larger than min)

        Parameterers
        ------------
        limit_type : str
            The name of the limit in the channel_limits dictionary
        bound : {&#34;min&#34;, &#34;max&#34;}
            Specifies if it is the max or the min limit that is to be set
        new_value : float
            The new value to be used for the limit
        verbose : bool
            Print confirmation that the limit was set or reason for why the
            limit was not set

        Returns
        -------
        bool
            `True` if new limit set, `False` otherwise
        &#34;&#34;&#34;
        # Short hand references
        inst_limit_dict = self.fgen.instrument_limits[limit_type]
        channel_limit_dict = self.channel_limits[limit_type]
        # Find the instrument limit and unit
        use_impedance = self.impedance_dependent_limit(limit_type)
        if use_impedance:
            inst_value = inst_limit_dict[0][self.impedance][bound]
        else:
            inst_value = inst_limit_dict[0][bound]
        unit = inst_limit_dict[1]
        # Check that the new value is within the intrument limits
        acceptable_min = bound == &#34;min&#34; and new_value &gt; inst_value
        if use_impedance:
            current_min = channel_limit_dict[0][self.impedance][&#34;min&#34;]
        else:
            current_min = channel_limit_dict[0][&#34;min&#34;]
        larger_than_min = new_value &gt; current_min
        acceptable_max = bound == &#34;max&#34; and new_value &lt; inst_value and larger_than_min
        if acceptable_min or acceptable_max: # within the limits
            # Set the new channel_limit, using the impedance depending on the
            # limit type. Beware that the shorthand cannot be used, as this
            # only changes the shorthand not the dictionary itself
            if use_impedance:
                self.channel_limits[limit_type][0][self.impedance][bound] = new_value
            else:
                self.channel_limits[limit_type][0][bound] = new_value
            if verbose:
                print(&#34;\tNew limit set {}{}&#34;.format(new_value, unit))
            return True
        elif verbose: # print description of why the limit was not set
            if larger_than_min:
                reason = &#34;larger&#34; if bound == &#34;max&#34; else &#34;smaller&#34;
                print(&#34;\tNew limit NOT set: {}{unit} is {} than the instrument &#34;
                      &#34;limit ({}{unit})&#34;.format(new_value, reason, inst_value,
                                                unit=unit))
            else:
                print(&#34;\tNew limit NOT set: {}{unit} is smaller than the &#34;
                      &#34;current set minimum ({}{unit})&#34;.format(new_value,
                                                              current_min,
                                                              unit=unit))
        return False

    # Get currently used parameters from function generator
    def get_output_state(self):
        &#34;&#34;&#34;Returns &#34;0&#34; for &#34;OFF&#34;, &#34;1&#34; for &#34;ON&#34; &#34;&#34;&#34;
        return self.fgen.query(&#34;OUTPut{}:STATe?&#34;.format(self.channel))

    def get_function(self):
        &#34;&#34;&#34;Returns string of function name&#34;&#34;&#34;
        return self.fgen.query(&#34;{}FUNCtion:SHAPe?&#34;.format(self.source))

    def get_amplitude(self):
        &#34;&#34;&#34;Returns peak-to-peak voltage in volts&#34;&#34;&#34;
        return float(self.fgen.query(&#34;{}VOLTage:AMPLitude?&#34;.format(self.source)))

    def get_offset(self):
        &#34;&#34;&#34;Returns offset voltage in volts&#34;&#34;&#34;
        return float(self.fgen.query(&#34;{}VOLTage:OFFSet?&#34;.format(self.source)))

    def get_frequency(self):
        &#34;&#34;&#34;Returns frequency in Hertz&#34;&#34;&#34;
        return float(self.fgen.query(&#34;{}FREQuency?&#34;.format(self.source)))

    # Get limits set in the channel class
    def get_frequency_lims(self):
        &#34;&#34;&#34;Returns list of min and max frequency limits&#34;&#34;&#34;
        return [self.channel_limits[&#34;frequency lims&#34;][0][key]
                for key in [&#34;min&#34;, &#34;max&#34;]]

    def get_voltage_lims(self):
        &#34;&#34;&#34;Returns list of min and max voltage limits for the current impedance&#34;&#34;&#34;
        return [self.channel_limits[&#34;voltage lims&#34;][0][self.impedance][key]
                for key in [&#34;min&#34;, &#34;max&#34;]]

    def get_amplitude_lims(self):
        &#34;&#34;&#34;Returns list of min and max amplitude limits for the current impedance&#34;&#34;&#34;
        return [self.channel_limits[&#34;amplitude lims&#34;][0][self.impedance][key]
                for key in [&#34;min&#34;, &#34;max&#34;]]

    def get_settings(self):
        &#34;&#34;&#34;Get the settings for the channel

        Returns
        -------
        current_settings : dict
            Settings currently in use as a dictionary with keys output,
            function, amplitude, offset, and frequency and values tuples of
            the corresponding return and unit
        &#34;&#34;&#34;
        return {&#34;output&#34;:    (self.state_str[self.get_output_state()], &#34;&#34;),
                &#34;function&#34;:  (self.get_function(),  &#34;&#34;),
                &#34;amplitude&#34;: (self.get_amplitude(), &#34;Vpp&#34;),
                &#34;offset&#34;:    (self.get_offset(),    &#34;V&#34;),
                &#34;frequency&#34;: (self.get_frequency(), &#34;Hz&#34;)}

    def print_settings(self):
        &#34;&#34;&#34;Print the settings currently in use for the channel (Recommended
        to use the `FuncGen.print_settings` for printing both channels)
        &#34;&#34;&#34;
        settings = self.get_settings()
        longest_key = max([len(key) for key in settings.keys()])
        print(&#34;\nCurrent settings for channel {}&#34;.format(self.channel))
        print(&#34;==============================&#34;)
        for key, (val, unit) in settings.items():
            print(&#34;{:&gt;{num_char}s} {} {}&#34;.format(key, val, unit,
                                                 num_char=longest_key))

    def set_settings(self, settings):
        &#34;&#34;&#34;Set the settings of the channel with a settings dictionary. Will
        set the outout to OFF before applyign the settings (and turn the
        channel ON or leave it OFF depending on the settings dict)

        Parameteres
        -----------
        settings : dict
            Settings dictionary as returned by `get_settings`: should have
            keys output, function, amplitude, offset, and frequency
        &#34;&#34;&#34;
        # First turn off to ensure no potentially harmful
        # combination of settings
        self.set_output_state(&#34;OFF&#34;)
        # Set settings according to dictionary
        self.set_function(settings[&#39;function&#39;][0])
        self.set_amplitude(settings[&#39;amplitude&#39;][0])
        self.set_offset(settings[&#39;offset&#39;][0])
        self.set_frequency(settings[&#39;frequency&#39;][0])
        self.set_output_state(settings[&#39;output&#39;][0])

    def set_output_state(self, state):
        &#34;&#34;&#34;Enables or diables the output of the channel

        Parameters
        ----------
        state : int or str
            &#34;ON&#34; or int 1 to enable
            &#34;OFF&#34; or int 0 to disable

        Raises
        ------
        NotSetError
            If `self.fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        err_msg = &#34;turn channel {} to state {}&#34;.format(self.channel, state)
        self.fgen.write(&#34;OUTPut{}:STATe {}&#34;.format(self.channel, state),
                                            custom_err_message=err_msg)
        if self.fgen.verify_param_set:
            actual_state = self.get_output_state()
            if not actual_state == state:
                msg = (&#34;Channel {} was not turned {}, it is {}.\n&#34;
                       &#34;Error from the instrument: {}&#34;
                       &#34;&#34;.format(self.channel, state,
                                 self.state_str[actual_state],
                                 self.fgen.get_error()))
                raise NotSetError(msg)

    def get_output(self):
        &#34;&#34;&#34;Wrapper for get_output_state&#34;&#34;&#34;
        return self.get_output_state()

    def set_output(self, state):
        &#34;&#34;&#34;Wrapper for set_output_state&#34;&#34;&#34;
        self.set_output_state(state)

    def set_function(self, shape):
        &#34;&#34;&#34;Set the function shape of the output

        Parameters
        ----------
        shape : {SINusoid, SQUare, PULSe, RAMP, PRNoise, &lt;Built_in&gt;, USER[0],
                 USER1, ..., USER255, EMEMory, EFILe}
            &lt;Built_in&gt;::={StairDown|StairUp|Stair Up&amp;Dwn|Trapezoid|RoundHalf|
            AbsSine|AbsHalfSine|ClippedSine|ChoppedSine|NegRamp|OscRise|
            OscDecay|CodedPulse|PosPulse|NegPulse|ExpRise|ExpDecay|Sinc|
            Tan|Cotan|SquareRoot|X^2|HaverSine|Lorentz|Ln(x)|X^3|CauchyDistr|
            BesselJ|BesselY|ErrorFunc|Airy|Rectangle|Gauss|Hamming|Hanning|
            Bartlett|Blackman|Laylight|Triangle|DC|Heart|Round|Chirp|Rhombus|
            Cardiac}

        Raises
        ------
        NotSetError
            If `self.fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        cmd = &#34;{}FUNCtion:SHAPe {}&#34;.format(self.source, shape)
        self.fgen.write(cmd, custom_err_message=&#34;set function {}&#34;.format(shape))
        if self.fgen.verify_param_set:
            actual_shape = self.get_function()
            if not actual_shape == shape:
                msg = (&#34;Function {} was not set on channel {}, it is {}. &#34;
                       &#34;Check that the function name is correctly spelt. &#34;
                       &#34;Run set_function.__doc__ to see available shapes.\n&#34;
                       &#34;Error from the instrument: {}&#34;
                       &#34;&#34;.format(shape, self.channel, actual_shape,
                                 self.fgen.get_error()))
                raise NotSetError(msg)

    def set_amplitude(self, amplitude):
        &#34;&#34;&#34;Set the peak-to-peak amplitude in volts

        Parameters
        ----------
        amplitude : float or {&#34;max&#34;, &#34;min&#34;}
            0.1mV or four digits resolution, &#34;max&#34; or &#34;min&#34; will set the
            amplitude to the maximum or minimum limit given in `channel_limits`

        Raises
        ------
        NotSetError
            If `self.fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        # Check if keyword min or max is given
        if str(amplitude).lower() in [&#34;min&#34;, &#34;max&#34;]:
            unit = &#34;&#34; # no unit for MIN/MAX
            # Look up what the limit is for this keyword
            amplitude = self.channel_limits[&#34;amplitude lims&#34;][0][self.impedance][str(amplitude).lower()]
        else:
            unit = &#34;Vpp&#34;
            # Check if the given amplitude is within the current limits
            min_ampl, max_ampl = self.get_amplitude_lims()
            if amplitude &lt; min_ampl or amplitude &gt; max_ampl:
                msg = (&#34;Could not set the amplitude {}{unit} as it is not &#34;
                       &#34;within the amplitude limits set for the instrument &#34;
                       &#34;[{}, {}]{unit}&#34;.format(amplitude, min_ampl, max_ampl,
                                               unit=unit))
                raise NotSetError(msg)
        # Check that the new amplitude will not violate voltage limits
        min_volt, max_volt = self.get_voltage_lims()
        current_offset = self.get_offset()
        if (amplitude/2-current_offset &lt; min_volt or
            amplitude/2+current_offset &gt; max_volt):
            msg = (&#34;Could not set the amplitude {}{unit} as the amplitude &#34;
                   &#34;combined with the offset ({}V) will be outside the &#34;
                   &#34;absolute voltage limits [{}, {}]{unit}&#34;
                   &#34;&#34;.format(amplitude, current_offset, min_volt, max_volt,
                             unit=unit))
            raise NotSetError(msg)
        # Set the amplitude
        cmd = &#34;{}VOLTage:LEVel {}{}&#34;.format(self.source, amplitude, unit)
        err_msg = &#34;set amplitude {}{}&#34;.format(amplitude, unit)
        self.fgen.write(cmd, custom_err_message=err_msg)
        # Verify that the amplitude has been set
        if self.fgen.verify_param_set:
            actual_amplitude = self.get_amplitude()
            # Multiply with the appropriate factor according to SI prefix, or
            # if string is empty, use the value looked up from channel_limits earlier
            if not unit == &#34;&#34;:
                check_amplitude = amplitude*self.SI_prefix_to_factor(unit)
            else:
                 check_amplitude = amplitude
            if not actual_amplitude == check_amplitude:
                msg = (&#34;Amplitude {}{} was not set on channel {}, it is &#34;
                       &#34;{}Vpp. Check that the number is within the possible &#34;
                       &#34;range and in the correct format.\nError from the &#34;
                       &#34;instrument: {}&#34;
                       &#34;&#34;.format(amplitude, unit, self.channel,
                                 actual_amplitude, self.fgen.get_error()))
                raise NotSetError(msg)

    def set_offset(self, offset, unit=&#34;V&#34;):
        &#34;&#34;&#34;Set offset in volts (or mV, see options)

        Parameters
        ----------
        offset : float
            Unknown resolution, guessing 0.1mV or four digits resolution
        unit : {mV, V}, default V

        Raises
        ------
        NotSetError
            If `self.fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        # Check that the new offset will not violate voltage limits
        min_volt, max_volt = self.get_voltage_lims()
        current_amplitude = self.get_amplitude()
        if (current_amplitude/2-offset &lt; min_volt or
            current_amplitude/2+offset &gt; max_volt):
            msg = (&#34;Could not set the offset {}{unit} as the offset combined&#34;
                   &#34;with the amplitude ({}V) will be outside the absolute &#34;
                   &#34;voltage limits [{}, {}]{unit}&#34;.format(offset,
                                                         current_amplitude,
                                                         min_volt, max_volt,
                                                         unit=unit))
            raise NotSetError(msg)
        # Set the offset
        cmd = &#34;{}VOLTage:LEVel:OFFSet {}{}&#34;.format(self.source, offset, unit)
        err_msg = &#34;set offset {}{}&#34;.format(offset, unit)
        self.fgen.write(cmd, custom_err_message=err_msg)
        # Verify that the offset has been set
        if self.fgen.verify_param_set:
            actual_offset = self.get_offset()
            # Multiply with the appropriate factor according to SI prefix
            check_offset = offset*self.SI_prefix_to_factor(unit)
            if not actual_offset == check_offset:
                msg = (&#34;Offset {}{} was not set on channel {}, it is {}V. &#34;
                       &#34;Check that the number is within the possible range and &#34;
                       &#34;in the correct format.\nError from the instrument: {}&#34;
                       &#34;&#34;.format(offset, unit, self.channel, actual_offset,
                                 self.fgen.get_error()))
                raise NotSetError(msg)

    def set_frequency(self, freq, unit=&#34;Hz&#34;):
        &#34;&#34;&#34;Set the frequency in Hertz (or kHz, MHz, see options)

        Parameters
        ----------
        freq : float
            The resolution is 1 Î¼Hz or 12 digits.
        unit : {Hz, kHz, MHz}, default Hz

        Raises
        ------
        NotSetError
            If `self.fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        if str(freq).lower() in [&#34;min&#34;, &#34;max&#34;]: # handle min and max keywords
            unit = &#34;&#34; # no unit for MIN/MAX
            # Look up what the limit is for this keyword
            freq = self.channel_limits[&#34;frequency lims&#34;][0][str(freq).lower()]
        else:
            # Check if the given frequency is within the current limits
            min_freq, max_freq = self.get_frequency_lims()
            if freq &lt; min_freq or freq &gt; max_freq:
                msg = (&#34;Could not set the frequency {}{} as it is not within &#34;
                       &#34;the frequency limits set for the instrument [{}, {}]&#34;
                       &#34;Hz&#34;.format(freq, unit, min_freq, max_freq))
                raise NotSetError(msg)
        # Check that the new amplitude will not violate voltage limits
        min_volt, max_volt = self.get_voltage_lims()
        # Set the frequency
        self.fgen.write(&#34;{}FREQuency:FIXed {}{}&#34;.format(self.source, freq, unit),
                            custom_err_message=&#34;set frequency {}{}&#34;.format(freq, unit))
        # Verify that the amplitude has been set
        if self.fgen.verify_param_set:
            actual_freq = self.get_frequency()
            # Multiply with the appropriate factor according to SI prefix, or
            # if string is empty, use the value looked up from channel_limits earlier
            if not unit == &#34;&#34;:
                check_freq = freq*self.SI_prefix_to_factor(unit)
            else:
                check_freq =  freq
            if not actual_freq == check_freq:
                msg = (&#34;Frequency {}{} was not set on channel {}, it is {}Hz. &#34;
                &#34;Check that the number is within the possible range and in &#34;
                &#34;the correct format.\nError from the instrument: {}&#34;
                &#34;&#34;.format(freq, unit, self.channel, actual_freq,
                            self.fgen.get_error()))
                raise NotSetError(msg)


    ## ~~~~~~~~~~~~~~~~~~~~~~~ AUXILLIARY ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##

    @staticmethod
    def SI_prefix_to_factor(unit):
        &#34;&#34;&#34;Convert an SI prefix to a numerical factor

        Parameters
        ----------
        unit : str
            The unit whose first character is checked against the list of
            prefactors {&#34;M&#34;: 1e6, &#34;k&#34;: 1e3, &#34;m&#34;: 1e-3}

        Returns
        -------
        factor : float or `None`
            The appropriate factor or 1 if not found in the list, or `None`
            if the unit string is empty
        &#34;&#34;&#34;
        # SI prefix to numerical value
        SI_conversion = {&#34;M&#34;:1e6, &#34;k&#34;:1e3, &#34;m&#34;:1e-3}
        try:  # using the unit&#39;s first character as key in the dictionary
            factor = SI_conversion[unit[0]]
        except KeyError:  # if the entry does not exist
            factor = 1
        except IndexError:  # if the unit string is empty
            factor = None
        return factor</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="tektronix_func_gen.FuncGenChannel.state_str"><code class="name">var <span class="ident">state_str</span></code></dt>
<dd>
<section class="desc"><p>Dictionary for converting output states to "ON" and "OFF"</p></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="tektronix_func_gen.FuncGenChannel.SI_prefix_to_factor"><code class="name flex">
<span>def <span class="ident">SI_prefix_to_factor</span></span>(<span>unit)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert an SI prefix to a numerical factor</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The unit whose first character is checked against the list of
prefactors {"M": 1e6, "k": 1e3, "m": 1e-3}</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>factor</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>The appropriate factor or 1 if not found in the list, or <code>None</code>
if the unit string is empty</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def SI_prefix_to_factor(unit):
    &#34;&#34;&#34;Convert an SI prefix to a numerical factor

    Parameters
    ----------
    unit : str
        The unit whose first character is checked against the list of
        prefactors {&#34;M&#34;: 1e6, &#34;k&#34;: 1e3, &#34;m&#34;: 1e-3}

    Returns
    -------
    factor : float or `None`
        The appropriate factor or 1 if not found in the list, or `None`
        if the unit string is empty
    &#34;&#34;&#34;
    # SI prefix to numerical value
    SI_conversion = {&#34;M&#34;:1e6, &#34;k&#34;:1e3, &#34;m&#34;:1e-3}
    try:  # using the unit&#39;s first character as key in the dictionary
        factor = SI_conversion[unit[0]]
    except KeyError:  # if the entry does not exist
        factor = 1
    except IndexError:  # if the unit string is empty
        factor = None
    return factor</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tektronix_func_gen.FuncGenChannel.get_amplitude"><code class="name flex">
<span>def <span class="ident">get_amplitude</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns peak-to-peak voltage in volts</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_amplitude(self):
    &#34;&#34;&#34;Returns peak-to-peak voltage in volts&#34;&#34;&#34;
    return float(self.fgen.query(&#34;{}VOLTage:AMPLitude?&#34;.format(self.source)))</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.get_amplitude_lims"><code class="name flex">
<span>def <span class="ident">get_amplitude_lims</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns list of min and max amplitude limits for the current impedance</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_amplitude_lims(self):
    &#34;&#34;&#34;Returns list of min and max amplitude limits for the current impedance&#34;&#34;&#34;
    return [self.channel_limits[&#34;amplitude lims&#34;][0][self.impedance][key]
            for key in [&#34;min&#34;, &#34;max&#34;]]</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.get_frequency"><code class="name flex">
<span>def <span class="ident">get_frequency</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns frequency in Hertz</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frequency(self):
    &#34;&#34;&#34;Returns frequency in Hertz&#34;&#34;&#34;
    return float(self.fgen.query(&#34;{}FREQuency?&#34;.format(self.source)))</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.get_frequency_lims"><code class="name flex">
<span>def <span class="ident">get_frequency_lims</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns list of min and max frequency limits</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frequency_lims(self):
    &#34;&#34;&#34;Returns list of min and max frequency limits&#34;&#34;&#34;
    return [self.channel_limits[&#34;frequency lims&#34;][0][key]
            for key in [&#34;min&#34;, &#34;max&#34;]]</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.get_function"><code class="name flex">
<span>def <span class="ident">get_function</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns string of function name</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function(self):
    &#34;&#34;&#34;Returns string of function name&#34;&#34;&#34;
    return self.fgen.query(&#34;{}FUNCtion:SHAPe?&#34;.format(self.source))</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.get_offset"><code class="name flex">
<span>def <span class="ident">get_offset</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns offset voltage in volts</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_offset(self):
    &#34;&#34;&#34;Returns offset voltage in volts&#34;&#34;&#34;
    return float(self.fgen.query(&#34;{}VOLTage:OFFSet?&#34;.format(self.source)))</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.get_output"><code class="name flex">
<span>def <span class="ident">get_output</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Wrapper for get_output_state</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_output(self):
    &#34;&#34;&#34;Wrapper for get_output_state&#34;&#34;&#34;
    return self.get_output_state()</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.get_output_state"><code class="name flex">
<span>def <span class="ident">get_output_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns "0" for "OFF", "1" for "ON"</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_output_state(self):
    &#34;&#34;&#34;Returns &#34;0&#34; for &#34;OFF&#34;, &#34;1&#34; for &#34;ON&#34; &#34;&#34;&#34;
    return self.fgen.query(&#34;OUTPut{}:STATe?&#34;.format(self.channel))</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.get_settings"><code class="name flex">
<span>def <span class="ident">get_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the settings for the channel</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>current_settings</code></strong> :&ensp;<code>dict</code></dt>
<dd>Settings currently in use as a dictionary with keys output,
function, amplitude, offset, and frequency and values tuples of
the corresponding return and unit</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_settings(self):
    &#34;&#34;&#34;Get the settings for the channel

    Returns
    -------
    current_settings : dict
        Settings currently in use as a dictionary with keys output,
        function, amplitude, offset, and frequency and values tuples of
        the corresponding return and unit
    &#34;&#34;&#34;
    return {&#34;output&#34;:    (self.state_str[self.get_output_state()], &#34;&#34;),
            &#34;function&#34;:  (self.get_function(),  &#34;&#34;),
            &#34;amplitude&#34;: (self.get_amplitude(), &#34;Vpp&#34;),
            &#34;offset&#34;:    (self.get_offset(),    &#34;V&#34;),
            &#34;frequency&#34;: (self.get_frequency(), &#34;Hz&#34;)}</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.get_voltage_lims"><code class="name flex">
<span>def <span class="ident">get_voltage_lims</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns list of min and max voltage limits for the current impedance</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_lims(self):
    &#34;&#34;&#34;Returns list of min and max voltage limits for the current impedance&#34;&#34;&#34;
    return [self.channel_limits[&#34;voltage lims&#34;][0][self.impedance][key]
            for key in [&#34;min&#34;, &#34;max&#34;]]</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.impedance_dependent_limit"><code class="name flex">
<span>def <span class="ident">impedance_dependent_limit</span></span>(<span>self, limit_type)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if the limit type is impedance dependent (voltages) or
not (frequency)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if the limit is impedance dependent</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def impedance_dependent_limit(self, limit_type):
    &#34;&#34;&#34;Check if the limit type is impedance dependent (voltages) or
    not (frequency)

    Returns
    -------
    bool
        `True` if the limit is impedance dependent
    &#34;&#34;&#34;
    try: # to access the key &#34;min&#34; to check if impedance must be selected
        _ = self.channel_limits[limit_type][0][&#34;min&#34;]
        return False
    except KeyError: # if the key does not exist
        # The impedance must be selected
        return True</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.print_settings"><code class="name flex">
<span>def <span class="ident">print_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Print the settings currently in use for the channel (Recommended
to use the <a title="tektronix_func_gen.FuncGen.print_settings" href="#tektronix_func_gen.FuncGen.print_settings"><code>FuncGen.print_settings()</code></a> for printing both channels)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_settings(self):
    &#34;&#34;&#34;Print the settings currently in use for the channel (Recommended
    to use the `FuncGen.print_settings` for printing both channels)
    &#34;&#34;&#34;
    settings = self.get_settings()
    longest_key = max([len(key) for key in settings.keys()])
    print(&#34;\nCurrent settings for channel {}&#34;.format(self.channel))
    print(&#34;==============================&#34;)
    for key, (val, unit) in settings.items():
        print(&#34;{:&gt;{num_char}s} {} {}&#34;.format(key, val, unit,
                                             num_char=longest_key))</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.set_amplitude"><code class="name flex">
<span>def <span class="ident">set_amplitude</span></span>(<span>self, amplitude)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the peak-to-peak amplitude in volts</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>amplitude</code></strong> :&ensp;<code>float</code> or {<code>"max"</code>, <code>"min"</code>}</dt>
<dd>0.1mV or four digits resolution, "max" or "min" will set the
amplitude to the maximum or minimum limit given in <code>channel_limits</code></dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><a title="tektronix_func_gen.NotSetError" href="#tektronix_func_gen.NotSetError"><code>NotSetError</code></a></dt>
<dd>If <code>self.fgen.verify_param_set</code> is <code>True</code> and the value after
applying the set function does not match the value returned by the
get function</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_amplitude(self, amplitude):
    &#34;&#34;&#34;Set the peak-to-peak amplitude in volts

    Parameters
    ----------
    amplitude : float or {&#34;max&#34;, &#34;min&#34;}
        0.1mV or four digits resolution, &#34;max&#34; or &#34;min&#34; will set the
        amplitude to the maximum or minimum limit given in `channel_limits`

    Raises
    ------
    NotSetError
        If `self.fgen.verify_param_set` is `True` and the value after
        applying the set function does not match the value returned by the
        get function
    &#34;&#34;&#34;
    # Check if keyword min or max is given
    if str(amplitude).lower() in [&#34;min&#34;, &#34;max&#34;]:
        unit = &#34;&#34; # no unit for MIN/MAX
        # Look up what the limit is for this keyword
        amplitude = self.channel_limits[&#34;amplitude lims&#34;][0][self.impedance][str(amplitude).lower()]
    else:
        unit = &#34;Vpp&#34;
        # Check if the given amplitude is within the current limits
        min_ampl, max_ampl = self.get_amplitude_lims()
        if amplitude &lt; min_ampl or amplitude &gt; max_ampl:
            msg = (&#34;Could not set the amplitude {}{unit} as it is not &#34;
                   &#34;within the amplitude limits set for the instrument &#34;
                   &#34;[{}, {}]{unit}&#34;.format(amplitude, min_ampl, max_ampl,
                                           unit=unit))
            raise NotSetError(msg)
    # Check that the new amplitude will not violate voltage limits
    min_volt, max_volt = self.get_voltage_lims()
    current_offset = self.get_offset()
    if (amplitude/2-current_offset &lt; min_volt or
        amplitude/2+current_offset &gt; max_volt):
        msg = (&#34;Could not set the amplitude {}{unit} as the amplitude &#34;
               &#34;combined with the offset ({}V) will be outside the &#34;
               &#34;absolute voltage limits [{}, {}]{unit}&#34;
               &#34;&#34;.format(amplitude, current_offset, min_volt, max_volt,
                         unit=unit))
        raise NotSetError(msg)
    # Set the amplitude
    cmd = &#34;{}VOLTage:LEVel {}{}&#34;.format(self.source, amplitude, unit)
    err_msg = &#34;set amplitude {}{}&#34;.format(amplitude, unit)
    self.fgen.write(cmd, custom_err_message=err_msg)
    # Verify that the amplitude has been set
    if self.fgen.verify_param_set:
        actual_amplitude = self.get_amplitude()
        # Multiply with the appropriate factor according to SI prefix, or
        # if string is empty, use the value looked up from channel_limits earlier
        if not unit == &#34;&#34;:
            check_amplitude = amplitude*self.SI_prefix_to_factor(unit)
        else:
             check_amplitude = amplitude
        if not actual_amplitude == check_amplitude:
            msg = (&#34;Amplitude {}{} was not set on channel {}, it is &#34;
                   &#34;{}Vpp. Check that the number is within the possible &#34;
                   &#34;range and in the correct format.\nError from the &#34;
                   &#34;instrument: {}&#34;
                   &#34;&#34;.format(amplitude, unit, self.channel,
                             actual_amplitude, self.fgen.get_error()))
            raise NotSetError(msg)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.set_frequency"><code class="name flex">
<span>def <span class="ident">set_frequency</span></span>(<span>self, freq, unit='Hz')</span>
</code></dt>
<dd>
<section class="desc"><p>Set the frequency in Hertz (or kHz, MHz, see options)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>freq</code></strong> :&ensp;<code>float</code></dt>
<dd>The resolution is 1 Î¼Hz or 12 digits.</dd>
<dt><strong><code>unit</code></strong> :&ensp;{<code>Hz</code>, <code>kHz</code>, <code>MHz</code>}, default <code>Hz</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><a title="tektronix_func_gen.NotSetError" href="#tektronix_func_gen.NotSetError"><code>NotSetError</code></a></dt>
<dd>If <code>self.fgen.verify_param_set</code> is <code>True</code> and the value after
applying the set function does not match the value returned by the
get function</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_frequency(self, freq, unit=&#34;Hz&#34;):
    &#34;&#34;&#34;Set the frequency in Hertz (or kHz, MHz, see options)

    Parameters
    ----------
    freq : float
        The resolution is 1 Î¼Hz or 12 digits.
    unit : {Hz, kHz, MHz}, default Hz

    Raises
    ------
    NotSetError
        If `self.fgen.verify_param_set` is `True` and the value after
        applying the set function does not match the value returned by the
        get function
    &#34;&#34;&#34;
    if str(freq).lower() in [&#34;min&#34;, &#34;max&#34;]: # handle min and max keywords
        unit = &#34;&#34; # no unit for MIN/MAX
        # Look up what the limit is for this keyword
        freq = self.channel_limits[&#34;frequency lims&#34;][0][str(freq).lower()]
    else:
        # Check if the given frequency is within the current limits
        min_freq, max_freq = self.get_frequency_lims()
        if freq &lt; min_freq or freq &gt; max_freq:
            msg = (&#34;Could not set the frequency {}{} as it is not within &#34;
                   &#34;the frequency limits set for the instrument [{}, {}]&#34;
                   &#34;Hz&#34;.format(freq, unit, min_freq, max_freq))
            raise NotSetError(msg)
    # Check that the new amplitude will not violate voltage limits
    min_volt, max_volt = self.get_voltage_lims()
    # Set the frequency
    self.fgen.write(&#34;{}FREQuency:FIXed {}{}&#34;.format(self.source, freq, unit),
                        custom_err_message=&#34;set frequency {}{}&#34;.format(freq, unit))
    # Verify that the amplitude has been set
    if self.fgen.verify_param_set:
        actual_freq = self.get_frequency()
        # Multiply with the appropriate factor according to SI prefix, or
        # if string is empty, use the value looked up from channel_limits earlier
        if not unit == &#34;&#34;:
            check_freq = freq*self.SI_prefix_to_factor(unit)
        else:
            check_freq =  freq
        if not actual_freq == check_freq:
            msg = (&#34;Frequency {}{} was not set on channel {}, it is {}Hz. &#34;
            &#34;Check that the number is within the possible range and in &#34;
            &#34;the correct format.\nError from the instrument: {}&#34;
            &#34;&#34;.format(freq, unit, self.channel, actual_freq,
                        self.fgen.get_error()))
            raise NotSetError(msg)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.set_function"><code class="name flex">
<span>def <span class="ident">set_function</span></span>(<span>self, shape)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the function shape of the output</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;{<code>SINusoid</code>, <code>SQUare</code>, <code>PULSe</code>, <code>RAMP</code>, <code>PRNoise</code>, &lt;<code>Built_in</code>&gt;, <code>USER</code>[<code>0</code>],</dt>
<dd>USER1, &hellip;, USER255, EMEMory, EFILe}
<Built_in>::={StairDown|StairUp|Stair Up&amp;Dwn|Trapezoid|RoundHalf|
AbsSine|AbsHalfSine|ClippedSine|ChoppedSine|NegRamp|OscRise|
OscDecay|CodedPulse|PosPulse|NegPulse|ExpRise|ExpDecay|Sinc|
Tan|Cotan|SquareRoot|X^2|HaverSine|Lorentz|Ln(x)|X^3|CauchyDistr|
BesselJ|BesselY|ErrorFunc|Airy|Rectangle|Gauss|Hamming|Hanning|
Bartlett|Blackman|Laylight|Triangle|DC|Heart|Round|Chirp|Rhombus|
Cardiac}</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><a title="tektronix_func_gen.NotSetError" href="#tektronix_func_gen.NotSetError"><code>NotSetError</code></a></dt>
<dd>If <code>self.fgen.verify_param_set</code> is <code>True</code> and the value after
applying the set function does not match the value returned by the
get function</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_function(self, shape):
    &#34;&#34;&#34;Set the function shape of the output

    Parameters
    ----------
    shape : {SINusoid, SQUare, PULSe, RAMP, PRNoise, &lt;Built_in&gt;, USER[0],
             USER1, ..., USER255, EMEMory, EFILe}
        &lt;Built_in&gt;::={StairDown|StairUp|Stair Up&amp;Dwn|Trapezoid|RoundHalf|
        AbsSine|AbsHalfSine|ClippedSine|ChoppedSine|NegRamp|OscRise|
        OscDecay|CodedPulse|PosPulse|NegPulse|ExpRise|ExpDecay|Sinc|
        Tan|Cotan|SquareRoot|X^2|HaverSine|Lorentz|Ln(x)|X^3|CauchyDistr|
        BesselJ|BesselY|ErrorFunc|Airy|Rectangle|Gauss|Hamming|Hanning|
        Bartlett|Blackman|Laylight|Triangle|DC|Heart|Round|Chirp|Rhombus|
        Cardiac}

    Raises
    ------
    NotSetError
        If `self.fgen.verify_param_set` is `True` and the value after
        applying the set function does not match the value returned by the
        get function
    &#34;&#34;&#34;
    cmd = &#34;{}FUNCtion:SHAPe {}&#34;.format(self.source, shape)
    self.fgen.write(cmd, custom_err_message=&#34;set function {}&#34;.format(shape))
    if self.fgen.verify_param_set:
        actual_shape = self.get_function()
        if not actual_shape == shape:
            msg = (&#34;Function {} was not set on channel {}, it is {}. &#34;
                   &#34;Check that the function name is correctly spelt. &#34;
                   &#34;Run set_function.__doc__ to see available shapes.\n&#34;
                   &#34;Error from the instrument: {}&#34;
                   &#34;&#34;.format(shape, self.channel, actual_shape,
                             self.fgen.get_error()))
            raise NotSetError(msg)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.set_limit"><code class="name flex">
<span>def <span class="ident">set_limit</span></span>(<span>self, limit_type, bound, new_value, verbose=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Set a limit if the new value is within the instrument limits and are
self consistent (max larger than min)</p>
<h2 id="parameterers">Parameterers</h2>
<dl>
<dt><strong><code>limit_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the limit in the channel_limits dictionary</dd>
<dt><strong><code>bound</code></strong> :&ensp;{<code>"min"</code>, <code>"max"</code>}</dt>
<dd>Specifies if it is the max or the min limit that is to be set</dd>
<dt><strong><code>new_value</code></strong> :&ensp;<code>float</code></dt>
<dd>The new value to be used for the limit</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Print confirmation that the limit was set or reason for why the
limit was not set</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if new limit set, <code>False</code> otherwise</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_limit(self, limit_type, bound, new_value, verbose=False):
    &#34;&#34;&#34;Set a limit if the new value is within the instrument limits and are
    self consistent (max larger than min)

    Parameterers
    ------------
    limit_type : str
        The name of the limit in the channel_limits dictionary
    bound : {&#34;min&#34;, &#34;max&#34;}
        Specifies if it is the max or the min limit that is to be set
    new_value : float
        The new value to be used for the limit
    verbose : bool
        Print confirmation that the limit was set or reason for why the
        limit was not set

    Returns
    -------
    bool
        `True` if new limit set, `False` otherwise
    &#34;&#34;&#34;
    # Short hand references
    inst_limit_dict = self.fgen.instrument_limits[limit_type]
    channel_limit_dict = self.channel_limits[limit_type]
    # Find the instrument limit and unit
    use_impedance = self.impedance_dependent_limit(limit_type)
    if use_impedance:
        inst_value = inst_limit_dict[0][self.impedance][bound]
    else:
        inst_value = inst_limit_dict[0][bound]
    unit = inst_limit_dict[1]
    # Check that the new value is within the intrument limits
    acceptable_min = bound == &#34;min&#34; and new_value &gt; inst_value
    if use_impedance:
        current_min = channel_limit_dict[0][self.impedance][&#34;min&#34;]
    else:
        current_min = channel_limit_dict[0][&#34;min&#34;]
    larger_than_min = new_value &gt; current_min
    acceptable_max = bound == &#34;max&#34; and new_value &lt; inst_value and larger_than_min
    if acceptable_min or acceptable_max: # within the limits
        # Set the new channel_limit, using the impedance depending on the
        # limit type. Beware that the shorthand cannot be used, as this
        # only changes the shorthand not the dictionary itself
        if use_impedance:
            self.channel_limits[limit_type][0][self.impedance][bound] = new_value
        else:
            self.channel_limits[limit_type][0][bound] = new_value
        if verbose:
            print(&#34;\tNew limit set {}{}&#34;.format(new_value, unit))
        return True
    elif verbose: # print description of why the limit was not set
        if larger_than_min:
            reason = &#34;larger&#34; if bound == &#34;max&#34; else &#34;smaller&#34;
            print(&#34;\tNew limit NOT set: {}{unit} is {} than the instrument &#34;
                  &#34;limit ({}{unit})&#34;.format(new_value, reason, inst_value,
                                            unit=unit))
        else:
            print(&#34;\tNew limit NOT set: {}{unit} is smaller than the &#34;
                  &#34;current set minimum ({}{unit})&#34;.format(new_value,
                                                          current_min,
                                                          unit=unit))
    return False</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.set_offset"><code class="name flex">
<span>def <span class="ident">set_offset</span></span>(<span>self, offset, unit='V')</span>
</code></dt>
<dd>
<section class="desc"><p>Set offset in volts (or mV, see options)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>offset</code></strong> :&ensp;<code>float</code></dt>
<dd>Unknown resolution, guessing 0.1mV or four digits resolution</dd>
<dt><strong><code>unit</code></strong> :&ensp;{<code>mV</code>, <code>V</code>}, default <code>V</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><a title="tektronix_func_gen.NotSetError" href="#tektronix_func_gen.NotSetError"><code>NotSetError</code></a></dt>
<dd>If <code>self.fgen.verify_param_set</code> is <code>True</code> and the value after
applying the set function does not match the value returned by the
get function</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_offset(self, offset, unit=&#34;V&#34;):
    &#34;&#34;&#34;Set offset in volts (or mV, see options)

    Parameters
    ----------
    offset : float
        Unknown resolution, guessing 0.1mV or four digits resolution
    unit : {mV, V}, default V

    Raises
    ------
    NotSetError
        If `self.fgen.verify_param_set` is `True` and the value after
        applying the set function does not match the value returned by the
        get function
    &#34;&#34;&#34;
    # Check that the new offset will not violate voltage limits
    min_volt, max_volt = self.get_voltage_lims()
    current_amplitude = self.get_amplitude()
    if (current_amplitude/2-offset &lt; min_volt or
        current_amplitude/2+offset &gt; max_volt):
        msg = (&#34;Could not set the offset {}{unit} as the offset combined&#34;
               &#34;with the amplitude ({}V) will be outside the absolute &#34;
               &#34;voltage limits [{}, {}]{unit}&#34;.format(offset,
                                                     current_amplitude,
                                                     min_volt, max_volt,
                                                     unit=unit))
        raise NotSetError(msg)
    # Set the offset
    cmd = &#34;{}VOLTage:LEVel:OFFSet {}{}&#34;.format(self.source, offset, unit)
    err_msg = &#34;set offset {}{}&#34;.format(offset, unit)
    self.fgen.write(cmd, custom_err_message=err_msg)
    # Verify that the offset has been set
    if self.fgen.verify_param_set:
        actual_offset = self.get_offset()
        # Multiply with the appropriate factor according to SI prefix
        check_offset = offset*self.SI_prefix_to_factor(unit)
        if not actual_offset == check_offset:
            msg = (&#34;Offset {}{} was not set on channel {}, it is {}V. &#34;
                   &#34;Check that the number is within the possible range and &#34;
                   &#34;in the correct format.\nError from the instrument: {}&#34;
                   &#34;&#34;.format(offset, unit, self.channel, actual_offset,
                             self.fgen.get_error()))
            raise NotSetError(msg)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.set_output"><code class="name flex">
<span>def <span class="ident">set_output</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Wrapper for set_output_state</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_output(self, state):
    &#34;&#34;&#34;Wrapper for set_output_state&#34;&#34;&#34;
    self.set_output_state(state)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.set_output_state"><code class="name flex">
<span>def <span class="ident">set_output_state</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"><p>Enables or diables the output of the channel</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>"ON" or int 1 to enable
"OFF" or int 0 to disable</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><a title="tektronix_func_gen.NotSetError" href="#tektronix_func_gen.NotSetError"><code>NotSetError</code></a></dt>
<dd>If <code>self.fgen.verify_param_set</code> is <code>True</code> and the value after
applying the set function does not match the value returned by the
get function</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_output_state(self, state):
    &#34;&#34;&#34;Enables or diables the output of the channel

    Parameters
    ----------
    state : int or str
        &#34;ON&#34; or int 1 to enable
        &#34;OFF&#34; or int 0 to disable

    Raises
    ------
    NotSetError
        If `self.fgen.verify_param_set` is `True` and the value after
        applying the set function does not match the value returned by the
        get function
    &#34;&#34;&#34;
    err_msg = &#34;turn channel {} to state {}&#34;.format(self.channel, state)
    self.fgen.write(&#34;OUTPut{}:STATe {}&#34;.format(self.channel, state),
                                        custom_err_message=err_msg)
    if self.fgen.verify_param_set:
        actual_state = self.get_output_state()
        if not actual_state == state:
            msg = (&#34;Channel {} was not turned {}, it is {}.\n&#34;
                   &#34;Error from the instrument: {}&#34;
                   &#34;&#34;.format(self.channel, state,
                             self.state_str[actual_state],
                             self.fgen.get_error()))
            raise NotSetError(msg)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.set_settings"><code class="name flex">
<span>def <span class="ident">set_settings</span></span>(<span>self, settings)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the settings of the channel with a settings dictionary. Will
set the outout to OFF before applyign the settings (and turn the
channel ON or leave it OFF depending on the settings dict)</p>
<h2 id="parameteres">Parameteres</h2>
<dl>
<dt><strong><code>settings</code></strong> :&ensp;<code>dict</code></dt>
<dd>Settings dictionary as returned by <code>get_settings</code>: should have
keys output, function, amplitude, offset, and frequency</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_settings(self, settings):
    &#34;&#34;&#34;Set the settings of the channel with a settings dictionary. Will
    set the outout to OFF before applyign the settings (and turn the
    channel ON or leave it OFF depending on the settings dict)

    Parameteres
    -----------
    settings : dict
        Settings dictionary as returned by `get_settings`: should have
        keys output, function, amplitude, offset, and frequency
    &#34;&#34;&#34;
    # First turn off to ensure no potentially harmful
    # combination of settings
    self.set_output_state(&#34;OFF&#34;)
    # Set settings according to dictionary
    self.set_function(settings[&#39;function&#39;][0])
    self.set_amplitude(settings[&#39;amplitude&#39;][0])
    self.set_offset(settings[&#39;offset&#39;][0])
    self.set_frequency(settings[&#39;frequency&#39;][0])
    self.set_output_state(settings[&#39;output&#39;][0])</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.set_stricter_limits"><code class="name flex">
<span>def <span class="ident">set_stricter_limits</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Set limits for the voltage and frequency limits of the channel output
through a series of prompts</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_stricter_limits(self):
    &#34;&#34;&#34;Set limits for the voltage and frequency limits of the channel output
    through a series of prompts&#34;&#34;&#34;
    print(&#34;Set stricter voltage and frequency limits &#34;
          &#34;for channel {}&#34;.format(self.channel))
    print(&#34;Use enter only to leave a limit unchanged.&#34;)
    # Go through the different limits in the instrument_limits dict
    for limit_type, (inst_limit_dict, unit) in self.fgen.instrument_limits.items():
        use_impedance = self.impedance_dependent_limit(limit_type)
        print(&#34;Set {} in {}&#34;.format(limit_type, unit), end=&#34; &#34;)
        if use_impedance:
            inst_limit_dict = inst_limit_dict[self.impedance]
            print(&#34;[{} impedance limit]&#34;.format(self.impedance))
        else:
            print(&#34;&#34;) # get new line
        # Go through the min and max for the limit type
        for key, inst_value in inst_limit_dict.items():
            # prompt for new value
            new_value = input(&#34;  {} (instrument limit {}{}): &#34;
                              &#34;&#34;.format(key, inst_value, unit))
            if new_value == &#34;&#34;:
                # Do not change if empty
                print(&#34;\tLimit not changed&#34;)
            else:
                try: # to convert to float
                    new_value = float(new_value)
                except ValueError:
                    print(&#34;\tLimit unchanged: Could not convert \&#39;{}\&#39; &#34;
                          &#34;to float&#34;.format(new_value))
                    continue # to next item in dict
                # Set the new limit
                self.set_limit(limit_type, key, new_value, verbose=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tektronix_func_gen.NotCompatibleError"><code class="flex name class">
<span>class <span class="ident">NotCompatibleError</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Error for when the instrument is not compatible with this module</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NotCompatibleError(Exception):
    &#34;&#34;&#34;Error for when the instrument is not compatible with this module&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="tektronix_func_gen.NotSetError"><code class="flex name class">
<span>class <span class="ident">NotSetError</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Error for when a value cannot be written to the instrument</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NotSetError(Exception):
    &#34;&#34;&#34;Error for when a value cannot be written to the instrument&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#tektronix-arbitrary-function-generator-control-through-pyvisa">Tektronix arbitrary function generator control through PyVISA</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tektronix_func_gen.example_basic_control" href="#tektronix_func_gen.example_basic_control">example_basic_control</a></code></li>
<li><code><a title="tektronix_func_gen.example_change_settings" href="#tektronix_func_gen.example_change_settings">example_change_settings</a></code></li>
<li><code><a title="tektronix_func_gen.example_changing_limits" href="#tektronix_func_gen.example_changing_limits">example_changing_limits</a></code></li>
<li><code><a title="tektronix_func_gen.example_lock_frequencies" href="#tektronix_func_gen.example_lock_frequencies">example_lock_frequencies</a></code></li>
<li><code><a title="tektronix_func_gen.example_set_and_use_custom_waveform" href="#tektronix_func_gen.example_set_and_use_custom_waveform">example_set_and_use_custom_waveform</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tektronix_func_gen.FuncGen" href="#tektronix_func_gen.FuncGen">FuncGen</a></code></h4>
<ul class="">
<li><code><a title="tektronix_func_gen.FuncGen.check_arb_waveform_length" href="#tektronix_func_gen.FuncGen.check_arb_waveform_length">check_arb_waveform_length</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.check_arb_waveform_type_and_range" href="#tektronix_func_gen.FuncGen.check_arb_waveform_type_and_range">check_arb_waveform_type_and_range</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.check_pyvisa_status" href="#tektronix_func_gen.FuncGen.check_pyvisa_status">check_pyvisa_status</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.close" href="#tektronix_func_gen.FuncGen.close">close</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.get_custom_waveform" href="#tektronix_func_gen.FuncGen.get_custom_waveform">get_custom_waveform</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.get_error" href="#tektronix_func_gen.FuncGen.get_error">get_error</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.get_frequency_lock" href="#tektronix_func_gen.FuncGen.get_frequency_lock">get_frequency_lock</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.get_settings" href="#tektronix_func_gen.FuncGen.get_settings">get_settings</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.get_waveform_catalogue" href="#tektronix_func_gen.FuncGen.get_waveform_catalogue">get_waveform_catalogue</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.initialise_model_properties" href="#tektronix_func_gen.FuncGen.initialise_model_properties">initialise_model_properties</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.normalise_to_waveform" href="#tektronix_func_gen.FuncGen.normalise_to_waveform">normalise_to_waveform</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.print_settings" href="#tektronix_func_gen.FuncGen.print_settings">print_settings</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.query" href="#tektronix_func_gen.FuncGen.query">query</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.set_custom_waveform" href="#tektronix_func_gen.FuncGen.set_custom_waveform">set_custom_waveform</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.set_frequency_lock" href="#tektronix_func_gen.FuncGen.set_frequency_lock">set_frequency_lock</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.set_settings" href="#tektronix_func_gen.FuncGen.set_settings">set_settings</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.software_trig" href="#tektronix_func_gen.FuncGen.software_trig">software_trig</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.spawn_channel" href="#tektronix_func_gen.FuncGen.spawn_channel">spawn_channel</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.syncronise_waveforms" href="#tektronix_func_gen.FuncGen.syncronise_waveforms">syncronise_waveforms</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.verify_waveform" href="#tektronix_func_gen.FuncGen.verify_waveform">verify_waveform</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.write" href="#tektronix_func_gen.FuncGen.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tektronix_func_gen.FuncGenChannel" href="#tektronix_func_gen.FuncGenChannel">FuncGenChannel</a></code></h4>
<ul class="">
<li><code><a title="tektronix_func_gen.FuncGenChannel.SI_prefix_to_factor" href="#tektronix_func_gen.FuncGenChannel.SI_prefix_to_factor">SI_prefix_to_factor</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_amplitude" href="#tektronix_func_gen.FuncGenChannel.get_amplitude">get_amplitude</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_amplitude_lims" href="#tektronix_func_gen.FuncGenChannel.get_amplitude_lims">get_amplitude_lims</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_frequency" href="#tektronix_func_gen.FuncGenChannel.get_frequency">get_frequency</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_frequency_lims" href="#tektronix_func_gen.FuncGenChannel.get_frequency_lims">get_frequency_lims</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_function" href="#tektronix_func_gen.FuncGenChannel.get_function">get_function</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_offset" href="#tektronix_func_gen.FuncGenChannel.get_offset">get_offset</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_output" href="#tektronix_func_gen.FuncGenChannel.get_output">get_output</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_output_state" href="#tektronix_func_gen.FuncGenChannel.get_output_state">get_output_state</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_settings" href="#tektronix_func_gen.FuncGenChannel.get_settings">get_settings</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_voltage_lims" href="#tektronix_func_gen.FuncGenChannel.get_voltage_lims">get_voltage_lims</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.impedance_dependent_limit" href="#tektronix_func_gen.FuncGenChannel.impedance_dependent_limit">impedance_dependent_limit</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.print_settings" href="#tektronix_func_gen.FuncGenChannel.print_settings">print_settings</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.set_amplitude" href="#tektronix_func_gen.FuncGenChannel.set_amplitude">set_amplitude</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.set_frequency" href="#tektronix_func_gen.FuncGenChannel.set_frequency">set_frequency</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.set_function" href="#tektronix_func_gen.FuncGenChannel.set_function">set_function</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.set_limit" href="#tektronix_func_gen.FuncGenChannel.set_limit">set_limit</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.set_offset" href="#tektronix_func_gen.FuncGenChannel.set_offset">set_offset</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.set_output" href="#tektronix_func_gen.FuncGenChannel.set_output">set_output</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.set_output_state" href="#tektronix_func_gen.FuncGenChannel.set_output_state">set_output_state</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.set_settings" href="#tektronix_func_gen.FuncGenChannel.set_settings">set_settings</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.set_stricter_limits" href="#tektronix_func_gen.FuncGenChannel.set_stricter_limits">set_stricter_limits</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.state_str" href="#tektronix_func_gen.FuncGenChannel.state_str">state_str</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tektronix_func_gen.NotCompatibleError" href="#tektronix_func_gen.NotCompatibleError">NotCompatibleError</a></code></h4>
</li>
<li>
<h4><code><a title="tektronix_func_gen.NotSetError" href="#tektronix_func_gen.NotSetError">NotSetError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>
